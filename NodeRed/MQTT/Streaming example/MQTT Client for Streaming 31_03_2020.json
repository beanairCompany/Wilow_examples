[{"id":"ea614234.df4b8","type":"tab","label":"MQTT Client for Streaming 31_03_2020","disabled":false,"info":""},{"id":"2a1fb8df.da04f8","type":"mqtt in","z":"ea614234.df4b8","name":"Broker","topic":"F0B5D1A48F4E0000/STREAMING","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":70,"y":500,"wires":[["84e242b3.d62da"]]},{"id":"b2ca74c0.20f0c8","type":"function","z":"ea614234.df4b8","name":"parsing","func":"// Decalre variable for each object we need from the streaming frame\nvar deviceType = {}\nvar dacType = {}\nvar time = {}\nvar samplingRate = {}\nvar channelsBitmap = {}\nvar frameId = {}\nvar numberDacPerChannel = {}\nvar previousNumberDacPerChannel = {}\nvar syncronizationStatus = {}\nvar data = {}\ndata.topic = \"data\"\n\n// local variable\nvar i // for the for statement\nvar dataLen // for the total number of measurements\n\n/*******************************/\n/* Parsing the streaming frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// timestamp and milliseconds\n// The time in the streaming mode frame in 6 bytes.\n// 4 bytes for the Reference time in Unix format)\n// 2 byte for the Reference millisecond\ntime.payload = {}\nfor(i=0; i<6; i++){\n    time.payload[i] = msg.payload[2+i]\n}\n// The sampling rate in 2 bytes\nsamplingRate.payload = {}\nfor(i=0; i<2; i++){\n    samplingRate.payload[i] = msg.payload[8+i]\n}\n// The channels bitmap is in 4 bytes\nchannelsBitmap.payload = {}\nfor(i=0; i<4; i++){\n    channelsBitmap.payload[i] = msg.payload[10+i]\n}\n// The frame Id in 3 byte\nframeId.payload = {}\nfor(i=0; i<3; i++){\n    frameId.payload[i] = msg.payload[14+i]\n}\n// The current number of samples per channel in 2 bytes\nnumberDacPerChannel.payload = {}\nfor(i=0; i<2; i++){\n    numberDacPerChannel.payload[i] = msg.payload[17+i]\n}\n// The previous number of samples per channel in 2 bytes\npreviousNumberDacPerChannel.payload = {}\nfor(i=0; i<2; i++){\n    previousNumberDacPerChannel.payload[i] = msg.payload[25+i]\n}\n\n// the syncronization status\nsyncronizationStatus.payload = msg.payload[27]\n        \n// The data (or measurements) is the rest of the payload\n// stream frame length - the header length (fixed objects) or multiply the number of samples by the number of active channels\ndataLen = msg.payload.length - 29\ndata.payload = []\nfor(i=0; i<dataLen; i++){\n    data.payload[i] = msg.payload[29+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, syncronizationStatus, channelsBitmap, data, numberDacPerChannel, previousNumberDacPerChannel, frameId, time, samplingRate]","outputs":10,"noerr":0,"x":480,"y":500,"wires":[["eb08c8e7.cf88b8"],["5892fc03.484604"],["fe861db1.2d429"],["d97597d.0cd1268"],["4d610a00.44b2b8"],["aa0fc702.d01ce8"],["883c4572.1dcac8"],["b1d25d42.deaf5"],["bff383d6.2c24d"],["9ae099a7.bf45c8"]]},{"id":"eb08c8e7.cf88b8","type":"function","z":"ea614234.df4b8","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":760,"y":280,"wires":[["23c2b893.49de98"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"5892fc03.484604","type":"function","z":"ea614234.df4b8","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":760,"y":340,"wires":[["23c2b893.49de98"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"d97597d.0cd1268","type":"function","z":"ea614234.df4b8","name":"get_channels","func":"/*\nthe channel bitmap is 4 bytes.\neach bit represent one channel status:\n    0 mean that channel is disable,\n    1 mean that channel enabel\nand from the bit index we can get the channel name\n*/\n\nvar channelsList=[]\nvar indexPos = 0;\nvar bitPos = 1\nvar i;\nfor(i=0; i<4; i++){\n    bitPos = 1\n    while(bitPos<=0x10){\n        if(msg.payload[i]&bitPos){\n            if(indexPos==0x00)\n                channelsList.push(\"Ch_Z\")\n            else if(indexPos==0x01)\n                channelsList.push(\"Ch_X\")\n            else if(indexPos==0x02)\n                channelsList.push(\"Ch_Y\")\n            else if(indexPos==0x03)\n                channelsList.push(\"Inc_X\")\n            else if(indexPos==0x04)\n                channelsList.push(\"Inc_Y\")\n        }\n        bitPos<<=1\n        indexPos+=1\n    }\n}\nmsg.payload = channelsList\nmsg.topic = \"channelsList\"\nreturn msg;","outputs":1,"noerr":0,"x":750,"y":460,"wires":[["4d610a00.44b2b8","578b4041.a5518"]]},{"id":"bff383d6.2c24d","type":"function","z":"ea614234.df4b8","name":"get-timestampAndMs","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timeStamp\"\nvar time_ms = {}\ntime_ms.topic = \"time_ms\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n// milliseconds\ntime_ms.payload = 0x0000\ntime_ms.payload |= msg.payload[4]\ntime_ms.payload |= msg.payload[5]<<8\n\nreturn [time_timeStamp, time_ms];","outputs":2,"noerr":0,"x":780,"y":780,"wires":[["f89ff35e.dadc"],["f89ff35e.dadc"]]},{"id":"e805e6b4.dac418","type":"function","z":"ea614234.df4b8","name":"get_dateTimeArray","func":"// input\nvar time_timeStamp = msg.payload.time_timeStamp\nvar time_ms = msg.payload.time_ms\nvar samplingRate = msg.payload.samplingRate\nvar frameId = msg.payload.frameId\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar previouseNbrDataPerChannel = msg.payload.previouseNbrDataPerChannel\n// output\nvar dataTimeArray = {}\ndataTimeArray.topic = \"dataTimeArray\"\n\ndataTimeArray.payload = []\nvar subPacketRow = 0\nfor(subPacketRow=0; subPacketRow<currentNbrDataPerChannel;subPacketRow++){\n    var subPacketIndex = (frameId * previouseNbrDataPerChannel) + subPacketRow\n    dataTimeArray.payload.push(time_timeStamp+time_ms/1000+((1/samplingRate)*subPacketIndex))\n}\nreturn dataTimeArray;","outputs":1,"noerr":0,"x":1330,"y":720,"wires":[["578b4041.a5518"]]},{"id":"f89ff35e.dadc","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"6","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":720,"wires":[["e805e6b4.dac418"]]},{"id":"b1d25d42.deaf5","type":"function","z":"ea614234.df4b8","name":"get_frameId","func":"//frame id in 3 bytes\nvar frameId = {}\nframeId.topic = \"frameId\"\n\nframeId.payload = 0x000000\nframeId.payload |= msg.payload[0]\nframeId.payload |= msg.payload[1]<<8\nframeId.payload |= msg.payload[2]<<16\n\nreturn frameId;","outputs":1,"noerr":0,"x":750,"y":720,"wires":[["f89ff35e.dadc","e63e1fe.0c727e"]]},{"id":"9ae099a7.bf45c8","type":"function","z":"ea614234.df4b8","name":"get_samplingRate","func":"//sampling rate in 2 bytes\nvar samplingRate = {}\nsamplingRate.topic = \"samplingRate\"\n\nsamplingRate.payload = 0x000000\nsamplingRate.payload |= msg.payload[0]\nsamplingRate.payload |= msg.payload[1]<<8\n\nreturn samplingRate;","outputs":1,"noerr":0,"x":770,"y":840,"wires":[["f89ff35e.dadc"]]},{"id":"aa0fc702.d01ce8","type":"function","z":"ea614234.df4b8","name":"get_currentNbrDataPerChannel","func":"//current number of data per channel in 2 bytes\nvar currentNbrDataPerChannel = {}\ncurrentNbrDataPerChannel.topic = \"currentNbrDataPerChannel\"\n\ncurrentNbrDataPerChannel.payload = 0x000000\ncurrentNbrDataPerChannel.payload |= msg.payload[0]\ncurrentNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn currentNbrDataPerChannel;","outputs":1,"noerr":0,"x":810,"y":540,"wires":[["f89ff35e.dadc","4d610a00.44b2b8"]]},{"id":"883c4572.1dcac8","type":"function","z":"ea614234.df4b8","name":"get_previouseNbrDataPerChannel","func":"//previouse number of data per channel in 2 bytes\nvar previouseNbrDataPerChannel = {}\npreviouseNbrDataPerChannel.topic = \"previouseNbrDataPerChannel\"\n\npreviouseNbrDataPerChannel.payload = 0x000000\npreviouseNbrDataPerChannel.payload |= msg.payload[0]\npreviouseNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn previouseNbrDataPerChannel;","outputs":1,"noerr":0,"x":820,"y":600,"wires":[["f89ff35e.dadc"]]},{"id":"3a941c32.148ad4","type":"function","z":"ea614234.df4b8","name":"get_dataArray","func":"// input\nvar data = msg.payload.data\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar nbrChannels = (msg.payload.channelsList).length\n// output\nvar dataArray = {}\ndataArray.topic = \"dataArray\"\n/* out put struction */\n/*\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 0 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 1 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n.\n.\n.\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel m | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n\n2 dimensional array\nfirst dimension for channels\nsecond dimension for data of each channel\n\n*/\n// indexs\nvar i=0 // for the number of channels\nvar j=0 // for the current number of data per channel\nvar pos=0 // to keep track of the index of data\n\ndataArray.payload = new Array(nbrChannels)\nfor(i=0; i<nbrChannels; i++){\n    dataArray.payload[i] = new Array(currentNbrDataPerChannel)\n    for(j=0; j<currentNbrDataPerChannel; j++){\n        pos = i*3+j*nbrChannels*3\n        // sample in 3 bytes (signed and LSB)\n        dataArray.payload[i][j] = 0x000000\n        dataArray.payload[i][j] |= data[pos]\n        dataArray.payload[i][j] |= (data[pos+1]<<8) \n        dataArray.payload[i][j] |= (data[pos+2]&0x7f<<16)\n        dataArray.payload[i][j] = dataArray.payload[i][j]/1000\n        //if sign bit equal 1 the measurement is negative\n        if((data[pos+2]&0x80)==0x80){\n            dataArray.payload[i][j] *= -1\n        }\n    }\n}\n\nreturn dataArray;","outputs":1,"noerr":0,"x":1320,"y":500,"wires":[["578b4041.a5518"]]},{"id":"4d610a00.44b2b8","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":500,"wires":[["3a941c32.148ad4"]]},{"id":"578b4041.a5518","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1530,"y":460,"wires":[["a0a0e107.63b1c","a00252de.5f9dd"]]},{"id":"4078aabc.871734","type":"ui_chart","z":"ea614234.df4b8","name":"Accelerometer","group":"82a1ef24.b8612","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1980,"y":460,"wires":[[]]},{"id":"947240cd.42007","type":"ui_text","z":"ea614234.df4b8","group":"82a1ef24.b8612","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\"  ({{msg.payload.synchronizationStatus}})","layout":"col-center","x":1950,"y":340,"wires":[]},{"id":"fe861db1.2d429","type":"function","z":"ea614234.df4b8","name":"get_synchronizationStatus","func":"var synchronizationStatus = {}\nsynchronizationStatus.topic = \"synchronizationStatus\"\n// synchronization status is the first bit\nif(msg.payload&0x01 == 1){\n    synchronizationStatus.payload = \"synchronized\"\n}\nelse{\n    synchronizationStatus.payload = \"not synchronized\"\n}\nreturn synchronizationStatus;","outputs":1,"noerr":0,"x":800,"y":400,"wires":[["23c2b893.49de98"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"23c2b893.49de98","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":340,"wires":[["947240cd.42007"]]},{"id":"d32c4a1c.fdd6d8","type":"ui_chart","z":"ea614234.df4b8","name":"Inclinometer ","group":"82a1ef24.b8612","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1970,"y":540,"wires":[[]]},{"id":"e63e1fe.0c727e","type":"function","z":"ea614234.df4b8","name":"reset graph","func":"/* input */\nvar frameId = msg.payload\n// list of global variable name of old measurements of each sensor type (tilt, inclinometer)\nvar listOfBuffer = [\n    \"oldTiltMeasurements\",\n    \"oldInclMeasurements\"]\n\n// if frameId = to 0, it means it's a new streaming, so clear the graph by clearing old measurement\nif(frameId==0){\n    for(var i=0; i<listOfBuffer.length; i++){\n        flow.set(listOfBuffer[i], [])\n    }\n}\n","outputs":0,"noerr":0,"x":890,"y":660,"wires":[]},{"id":"84e242b3.d62da","type":"function","z":"ea614234.df4b8","name":"MQTT frame verification","func":"/*\nBecause the STREAMING topic is not reserved only for streaming mode data\n(shared with dynamic math result, SET and Shock detection),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x03 \nwhich is the code for the streaming mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's a streaming frame\nif(msg.payload[1]!=0x03){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":270,"y":500,"wires":[["b2ca74c0.20f0c8"]]},{"id":"245bc95e.900316","type":"comment","z":"ea614234.df4b8","name":"Read me","info":"Company: BeanAir\nDate:   31/03/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in streaming mode and display it in graph. \nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\n(Note: \n    + Data sample in 3 bytes, the last bit is a sign bit and all field are LSB first\n    + Time is in 6 bytes, 4 fr the reference time in unix format and the last 2 bytes for milliseconds)\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference docuement: \n    + http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n    \nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for dynamic measurement\n3- Start running the beandevice in Streaming mode\n\nSteps of this flow:\n1- connect to the broker\n2- subscribe to the topic \"STREAMING\" which is the topic for the dynamic measurement\n3- wait for payloads\n4- check DAC type if it's streaming\n5- parse the coming payload\n6- check if it's a new streaming (frame id = 0),if it is then clear the graph.(this will make the graph clean in streaming burst mode)\n6- display data in graph","x":80,"y":420,"wires":[]},{"id":"a0a0e107.63b1c","type":"function","z":"ea614234.df4b8","name":"to accelerometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nvar filter = \"ch\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldAccelerometerMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1740,"y":460,"wires":[["4078aabc.871734"]]},{"id":"a00252de.5f9dd","type":"function","z":"ea614234.df4b8","name":"to inclinometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nvar filter = \"inc\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldInclMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1750,"y":540,"wires":[["d32c4a1c.fdd6d8"]]},{"id":"5ab5d8b8.d82498","type":"mqtt-broker","z":"","name":"hivemq broker","broker":"broker.hivemq.com","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"82a1ef24.b8612","type":"ui_group","z":"ea614234.df4b8","name":"MQTT Streaming","tab":"c73c6760.32bfa8","order":1,"disp":true,"width":"25","collapse":false},{"id":"c73c6760.32bfa8","type":"ui_tab","z":"ea614234.df4b8","name":"BeanAir: Streaming","icon":"dashboard","order":7,"disabled":false,"hidden":false}]
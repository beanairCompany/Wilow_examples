[{"id":"19e325ac.ee4faa","type":"tab","label":"MQTT Client for Shock Detection 02_04_2020","disabled":false,"info":""},{"id":"bdc0fe22.781c9","type":"mqtt in","z":"19e325ac.ee4faa","name":"Broker","topic":"F0B5D1A48F4E0000/STREAMING","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":70,"y":500,"wires":[["7e57ed51.196614"]]},{"id":"b9c1de8f.cd1ff","type":"function","z":"19e325ac.ee4faa","name":"parsing","func":"// Decalre variable for each object we need from the SSD frame\nvar deviceType = {}\nvar dacType = {}\nvar time = {}\nvar samplingRate = {}\nvar channelsBitmap = {}\nvar frameId = {}\nvar numberDacPerChannel = {}\nvar previousNumberDacPerChannel = {}\nvar syncronizationStatus = {}\nvar shockInfo = {}\nvar data = {}\ndata.topic = \"data\"\n\n// local variable\nvar i // for the for statement\nvar dataLen // for the total number of measurements\n\n/*******************************/\n/* Parsing the streaming frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// timestamp and milliseconds\n// The time in the streaming mode frame in 6 bytes.\n// 4 bytes for the Reference time in Unix format)\n// 2 byte for the Reference millisecond\ntime.payload = []\nfor(i=0; i<6; i++){\n    time.payload[i] = msg.payload[2+i]\n}\n// The sampling rate in 2 bytes\nsamplingRate.payload = []\nfor(i=0; i<2; i++){\n    samplingRate.payload[i] = msg.payload[8+i]\n}\n// The channels bitmap is in 4 bytes\nchannelsBitmap.payload = []\nfor(i=0; i<4; i++){\n    channelsBitmap.payload[i] = msg.payload[10+i]\n}\n// The frame Id in 3 byte\nframeId.payload = []\nfor(i=0; i<3; i++){\n    frameId.payload[i] = msg.payload[14+i]\n}\n// The current number of samples per channel in 2 bytes\nnumberDacPerChannel.payload = []\nfor(i=0; i<2; i++){\n    numberDacPerChannel.payload[i] = msg.payload[17+i]\n}\n// The previous number of samples per channel in 2 bytes\npreviousNumberDacPerChannel.payload = []\nfor(i=0; i<2; i++){\n    previousNumberDacPerChannel.payload[i] = msg.payload[25+i]\n}\n\n// the syncronization status\nsyncronizationStatus.payload = msg.payload[27]\n \n// shock informations in 7 bytes (1 byte for shock source, 2 bytes for data for each channel (X, Y and Z) )\nshockInfo.payload = []\nfor(i=0; i<7; i++){\n    shockInfo.payload[i] = msg.payload[29+i]\n}\n       \n// The data (or measurements) is the rest of the payload\n// frame length - the header length (fixed objects) or multiply the number of samples by the number of active channels\ndataLen = msg.payload.length - 36\ndata.payload = []\nfor(i=0; i<dataLen; i++){\n    data.payload[i] = msg.payload[36+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, syncronizationStatus, channelsBitmap, data, numberDacPerChannel, previousNumberDacPerChannel, frameId, time, samplingRate, shockInfo]","outputs":11,"noerr":0,"x":480,"y":500,"wires":[["d7af67a7.84dad8"],["a9009d8f.3326a"],["a5dc8a57.48d1c8"],["c845156e.0d5b58"],["e832dee8.0b135"],["a7aec0eb.a8f21"],["27a4a24b.c19a9e"],["777805ee.2c8edc"],["b84b45b2.65b038"],["a57efc44.d559c"],["d4f99a24.3c2e38"]]},{"id":"d7af67a7.84dad8","type":"function","z":"19e325ac.ee4faa","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":760,"y":280,"wires":[["3206635f.1f385c"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"a9009d8f.3326a","type":"function","z":"19e325ac.ee4faa","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":760,"y":340,"wires":[["3206635f.1f385c"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"c845156e.0d5b58","type":"function","z":"19e325ac.ee4faa","name":"get_channels","func":"/*\nthe channel bitmap is 4 bytes.\neach bit represent one channel status:\n    0 mean that channel is disable,\n    1 mean that channel enabel\nand from the bit index we can get the channel name\n*/\n\nvar channelsList=[]\nvar indexPos = 0;\nvar bitPos = 1\nvar i;\nfor(i=0; i<4; i++){\n    bitPos = 1\n    while(bitPos<=0x10){\n        if(msg.payload[i]&bitPos){\n            if(indexPos==0x00)\n                channelsList.push(\"Ch_Z\")\n            else if(indexPos==0x01)\n                channelsList.push(\"Ch_X\")\n            else if(indexPos==0x02)\n                channelsList.push(\"Ch_Y\")\n            else if(indexPos==0x03)\n                channelsList.push(\"Inc_X\")\n            else if(indexPos==0x04)\n                channelsList.push(\"Inc_Y\")\n        }\n        bitPos<<=1\n        indexPos+=1\n    }\n}\nmsg.payload = channelsList\nmsg.topic = \"channelsList\"\nreturn msg;","outputs":1,"noerr":0,"x":750,"y":460,"wires":[["e832dee8.0b135","6a644c7d.07f194"]]},{"id":"b84b45b2.65b038","type":"function","z":"19e325ac.ee4faa","name":"get-timestampAndMs","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timeStamp\"\nvar time_ms = {}\ntime_ms.topic = \"time_ms\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n// milliseconds\ntime_ms.payload = 0x0000\ntime_ms.payload |= msg.payload[4]\ntime_ms.payload |= msg.payload[5]<<8\n\nreturn [time_timeStamp, time_ms];","outputs":2,"noerr":0,"x":780,"y":780,"wires":[["f03bd673.d29288"],["f03bd673.d29288"]]},{"id":"71919003.ce605","type":"function","z":"19e325ac.ee4faa","name":"get_dateTimeArray","func":"// input\nvar time_timeStamp = msg.payload.time_timeStamp\nvar time_ms = msg.payload.time_ms\nvar samplingRate = msg.payload.samplingRate\nvar frameId = msg.payload.frameId\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar previouseNbrDataPerChannel = msg.payload.previouseNbrDataPerChannel\n// output\nvar dataTimeArray = {}\ndataTimeArray.topic = \"dataTimeArray\"\n\ndataTimeArray.payload = []\nvar subPacketRow = 0\nfor(subPacketRow=0; subPacketRow<currentNbrDataPerChannel;subPacketRow++){\n    var subPacketIndex = (frameId * previouseNbrDataPerChannel) + subPacketRow\n    dataTimeArray.payload.push(time_timeStamp+time_ms/1000+((1/samplingRate)*subPacketIndex))\n}\nreturn dataTimeArray;","outputs":1,"noerr":0,"x":1330,"y":720,"wires":[["6a644c7d.07f194"]]},{"id":"f03bd673.d29288","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"6","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":720,"wires":[["71919003.ce605"]]},{"id":"777805ee.2c8edc","type":"function","z":"19e325ac.ee4faa","name":"get_frameId","func":"//frame id in 3 bytes\nvar frameId = {}\nframeId.topic = \"frameId\"\n\nframeId.payload = 0x000000\nframeId.payload |= msg.payload[0]\nframeId.payload |= msg.payload[1]<<8\nframeId.payload |= msg.payload[2]<<16\n\nreturn frameId;","outputs":1,"noerr":0,"x":750,"y":720,"wires":[["f03bd673.d29288","91bc5c9.2b7d9a"]]},{"id":"a57efc44.d559c","type":"function","z":"19e325ac.ee4faa","name":"get_samplingRate","func":"//sampling rate in 2 bytes\nvar samplingRate = {}\nsamplingRate.topic = \"samplingRate\"\n\nsamplingRate.payload = 0x000000\nsamplingRate.payload |= msg.payload[0]\nsamplingRate.payload |= msg.payload[1]<<8\n\nreturn samplingRate;","outputs":1,"noerr":0,"x":770,"y":840,"wires":[["f03bd673.d29288"]]},{"id":"a7aec0eb.a8f21","type":"function","z":"19e325ac.ee4faa","name":"get_currentNbrDataPerChannel","func":"//current number of data per channel in 2 bytes\nvar currentNbrDataPerChannel = {}\ncurrentNbrDataPerChannel.topic = \"currentNbrDataPerChannel\"\n\ncurrentNbrDataPerChannel.payload = 0x000000\ncurrentNbrDataPerChannel.payload |= msg.payload[0]\ncurrentNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn currentNbrDataPerChannel;","outputs":1,"noerr":0,"x":810,"y":540,"wires":[["f03bd673.d29288","e832dee8.0b135"]]},{"id":"27a4a24b.c19a9e","type":"function","z":"19e325ac.ee4faa","name":"get_previouseNbrDataPerChannel","func":"//previouse number of data per channel in 2 bytes\nvar previouseNbrDataPerChannel = {}\npreviouseNbrDataPerChannel.topic = \"previouseNbrDataPerChannel\"\n\npreviouseNbrDataPerChannel.payload = 0x000000\npreviouseNbrDataPerChannel.payload |= msg.payload[0]\npreviouseNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn previouseNbrDataPerChannel;","outputs":1,"noerr":0,"x":820,"y":600,"wires":[["f03bd673.d29288"]]},{"id":"bc6f9279.0ef21","type":"function","z":"19e325ac.ee4faa","name":"get_dataArray","func":"// input\nvar data = msg.payload.data\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar nbrChannels = (msg.payload.channelsList).length\n// output\nvar dataArray = {}\ndataArray.topic = \"dataArray\"\n/* out put struction */\n/*\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 0 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 1 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n.\n.\n.\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel m | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n\n2 dimensional array\nfirst dimension for channels\nsecond dimension for data of each channel\n\n*/\n// indexs\nvar i=0 // for the number of channels\nvar j=0 // for the current number of data per channel\nvar pos=0 // to keep track of the index of data\n\ndataArray.payload = new Array(nbrChannels)\nfor(i=0; i<nbrChannels; i++){\n    dataArray.payload[i] = new Array(currentNbrDataPerChannel)\n    for(j=0; j<currentNbrDataPerChannel; j++){\n        pos = i*3+j*nbrChannels*3\n        // sample in 3 bytes (signed and LSB)\n        dataArray.payload[i][j] = 0x000000\n        dataArray.payload[i][j] |= data[pos]\n        dataArray.payload[i][j] |= (data[pos+1]<<8) \n        dataArray.payload[i][j] |= (data[pos+2]&0x7f<<16)\n        dataArray.payload[i][j] = dataArray.payload[i][j]/1000\n        //if sign bit equal 1 the measurement is negative\n        if((data[pos+2]&0x80)==0x80){\n            dataArray.payload[i][j] *= -1\n        }\n    }\n}\n\nreturn dataArray;","outputs":1,"noerr":0,"x":1320,"y":500,"wires":[["6a644c7d.07f194"]]},{"id":"e832dee8.0b135","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":500,"wires":[["bc6f9279.0ef21"]]},{"id":"6a644c7d.07f194","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1530,"y":460,"wires":[["bce018ab.9e6dd8","64883632.96dbf8"]]},{"id":"e52fa54b.4c30b8","type":"ui_chart","z":"19e325ac.ee4faa","name":"Accelerometer","group":"ef1869fd.367b78","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1980,"y":460,"wires":[[]]},{"id":"38f238d7.cf3bb8","type":"ui_text","z":"19e325ac.ee4faa","group":"ef1869fd.367b78","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\"  ({{msg.payload.synchronizationStatus}})","layout":"col-center","x":1950,"y":340,"wires":[]},{"id":"a5dc8a57.48d1c8","type":"function","z":"19e325ac.ee4faa","name":"get_synchronizationStatus","func":"var synchronizationStatus = {}\nsynchronizationStatus.topic = \"synchronizationStatus\"\n// synchronization status is the first bit\nif(msg.payload&0x01 == 1){\n    synchronizationStatus.payload = \"synchronized\"\n}\nelse{\n    synchronizationStatus.payload = \"not synchronized\"\n}\nreturn synchronizationStatus;","outputs":1,"noerr":0,"x":800,"y":400,"wires":[["3206635f.1f385c"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"3206635f.1f385c","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":340,"wires":[["38f238d7.cf3bb8"]]},{"id":"df079c91.db755","type":"ui_chart","z":"19e325ac.ee4faa","name":"Inclinometer ","group":"ef1869fd.367b78","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1970,"y":540,"wires":[[]]},{"id":"91bc5c9.2b7d9a","type":"function","z":"19e325ac.ee4faa","name":"reset graph","func":"/* input */\nvar frameId = msg.payload\n// list of global variable name of old measurements of each sensor type (tilt, inclinometer)\nvar listOfBuffer = [\n    \"oldTiltMeasurements\",\n    \"oldInclMeasurements\"]\n\n// if frameId = to 0, it means it's a new streaming, so clear the graph by clearing old measurement\nif(frameId==0){\n    for(var i=0; i<listOfBuffer.length; i++){\n        flow.set(listOfBuffer[i], [])\n    }\n}\n","outputs":0,"noerr":0,"x":890,"y":660,"wires":[]},{"id":"7e57ed51.196614","type":"function","z":"19e325ac.ee4faa","name":"MQTT frame verification","func":"/*\nBecause the STREAMING topic is not reserved only for SSD mode data\n(shared with dynamic math result, SET and Streaming),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x03 \nwhich is the code for the SSD mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's a SSD frame\nif(msg.payload[1]!=0x04){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":270,"y":500,"wires":[["b9c1de8f.cd1ff"]]},{"id":"cffd7571.92cf28","type":"comment","z":"19e325ac.ee4faa","name":"Read me","info":"Company: BeanAir\nDate:   02/04/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in SSD mode and display it in graph. \nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\n(Note: \n    + Data sample in 3 bytes, the last bit is a sign bit and all field are LSB first\n    + X, Y and Z first data (2 bytes) uses the 2's compelement format\n    + Time is in 6 bytes, 4 fr the reference time in unix format and the last 2 bytes for milliseconds)\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference docuement: \n    + http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n    \nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for dynamic measurement\n3- Start running the beandevice in Shock Detection mode\n\nSteps of this flow:\n1- connect to the broker\n2- subscribe to the topic \"STREAMING\" which is the topic for the dynamic measurement\n3- wait for payloads\n4- check DAC type if it's Shock detection\n5- parse the coming payload\n6- check if it's a new streaming (frame id = 0),if it is then clear the graph.\n6- display data in graph","x":80,"y":420,"wires":[]},{"id":"d4f99a24.3c2e38","type":"function","z":"19e325ac.ee4faa","name":"get_shock dection informations","func":"//shock detection in 7 bytes\n// first byte for shock source (X, Y or Z)\n// the value of each sensor in 2 bytes (uses the 2's compelement format)\nvar shockSource = msg.payload[0]\n\nif(shockSource==0x00)\n    shockSource = \"Z axis\"\nelse if(shockSource==0x01)\n    shockSource = \"X axis\"\nelse if(shockSource==0x02)\n    shockSource = \"Y axis\"\n\n// get value and use 2's complement to convert them to decimal\n// because the bitwise operation 'NOT' will effect the 32 bits (other machine 64 bits depends on decimal size) and not the 2 bytes\n// we need to keep only the first 2 bytes\n// which require to use of the bitmask. (0xff) \n\nvar x_value = 0\nx_value += msg.payload[1]\nx_value += msg.payload[2] << 8\nif(x_value>0x8000){\n    x_value = ~x_value\n    x_value = x_value >>> 0\n    x_value &= 0xffff\n    x_value += 1\n    y_value *= -1\n}\nx_value = x_value/1000\n\nvar y_value = 0\ny_value += msg.payload[3]\ny_value += msg.payload[4] << 8\nif(y_value>0x8000){\n    y_value = ((~y_value>>>0) & 0x0000ffff)+1\n    y_value *= -1\n}\ny_value = y_value/1000\n\nvar z_value = 0\nz_value += msg.payload[5]\nz_value += msg.payload[6] << 8\nif(z_value>0x8000){\n   z_value = ((~z_value>>>0) & 0xffff)+1\n   z_value *= -1\n}\nz_value = z_value/1000\n\n\nmsg.payload = {}\nmsg.payload.source = shockSource\nmsg.payload.x = x_value\nmsg.payload.y = y_value\nmsg.payload.z = z_value\n\nreturn msg;","outputs":1,"noerr":0,"x":810,"y":900,"wires":[["a342529f.a3dc4"]]},{"id":"a342529f.a3dc4","type":"ui_text","z":"19e325ac.ee4faa","group":"ef1869fd.367b78","order":10,"width":0,"height":0,"name":"","label":"","format":"Shock source: {{msg.payload.source}} \"X axis: {{msg.payload.x}} ; Y axis: {{msg.payload.y}} ; Z axis: {{msg.payload.z}}\"","layout":"col-center","x":1950,"y":900,"wires":[]},{"id":"bce018ab.9e6dd8","type":"function","z":"19e325ac.ee4faa","name":"to accelerometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nvar filter = \"ch\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldAccelerometerMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1740,"y":460,"wires":[["e52fa54b.4c30b8"]]},{"id":"64883632.96dbf8","type":"function","z":"19e325ac.ee4faa","name":"to inclinometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nvar filter = \"inc\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldInclMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1750,"y":540,"wires":[["df079c91.db755"]]},{"id":"5ab5d8b8.d82498","type":"mqtt-broker","z":"","name":"hivemq broker","broker":"broker.hivemq.com","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"ef1869fd.367b78","type":"ui_group","z":"19e325ac.ee4faa","name":"MQTT Shock Detection","tab":"43c22f6b.2e6ec","order":1,"disp":true,"width":"25","collapse":false},{"id":"43c22f6b.2e6ec","type":"ui_tab","z":"19e325ac.ee4faa","name":"BeanAir: Shock Detection","icon":"dashboard","order":4,"disabled":false,"hidden":false}]
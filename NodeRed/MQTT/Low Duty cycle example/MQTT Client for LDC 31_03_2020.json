[{"id":"eaf85255.d8106","type":"tab","label":"MQTT Client for LDC 31_03_2020","disabled":false,"info":""},{"id":"a574b82f.bda7e8","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/0)","topic":"F0B5D1A48F4E0000/SENSOR/0","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":380,"wires":[["134d2a15.d4f396"]]},{"id":"8b93cb85.d95b78","type":"function","z":"eaf85255.d8106","name":"parsing","func":"// Decalre variable for each object we need from the MQTT frame\nvar deviceType = {}\nvar dacType = {}\nvar channelId = {}\nvar time = {}\nvar data = {}\n\n/*******************************/\n/* Parsing the LDC frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// channel id\nchannelId.payload = msg.payload[2]\n\n// Reference time (in Unix format) (4 bytes) \ntime.payload = []\nfor(i=0; i<4; i++){\n    time.payload[i] = msg.payload[3+i]\n}\n\n// data in 3 bytes\ndata.payload = []\nfor(i=0; i<3; i++){\n    data.payload[i] = msg.payload[7+i]\n}\n\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, channelId, time, data]","outputs":5,"noerr":0,"x":640,"y":500,"wires":[["797cdaaf.bdffc4"],["f51cea0f.f1e7a8"],["9ef1fdf0.166dc"],["85e23b66.cb8b08"],["e86d16a4.4d8228"]]},{"id":"797cdaaf.bdffc4","type":"function","z":"eaf85255.d8106","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":880,"y":380,"wires":[["c6fc1247.08585"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"f51cea0f.f1e7a8","type":"function","z":"eaf85255.d8106","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"later\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":880,"y":440,"wires":[["c6fc1247.08585"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"85e23b66.cb8b08","type":"function","z":"eaf85255.d8106","name":"get-timestamp","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timestamp\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n\n\nreturn time_timeStamp;","outputs":1,"noerr":0,"x":880,"y":560,"wires":[["207c4320.3de5fc"]]},{"id":"207c4320.3de5fc","type":"join","z":"eaf85255.d8106","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":560,"wires":[["e5d813a.6f396f","683b459f.e2625c"]]},{"id":"e5d813a.6f396f","type":"function","z":"eaf85255.d8106","name":"to accelerometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nfilter = \"ch\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedAccelerometerMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    \n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1400,"y":520,"wires":[["23a5521b.e568fe"]]},{"id":"23a5521b.e568fe","type":"ui_chart","z":"eaf85255.d8106","name":"Accelerometer","group":"5e904f96.9d93d","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1620,"y":520,"wires":[[]]},{"id":"40e65d07.edb394","type":"ui_text","z":"eaf85255.d8106","group":"5e904f96.9d93d","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\" ","layout":"col-center","x":1590,"y":380,"wires":[]},{"id":"c6fc1247.08585","type":"join","z":"eaf85255.d8106","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":380,"wires":[["40e65d07.edb394"]]},{"id":"d16f5d66.0c632","type":"ui_chart","z":"eaf85255.d8106","name":"Inclinometer ","group":"5e904f96.9d93d","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1610,"y":600,"wires":[[]]},{"id":"134d2a15.d4f396","type":"function","z":"eaf85255.d8106","name":"MQTT frame verification","func":"/*\nBecause the Static topic is not reserved only for LowDutyCycle mode data\n(shared with ldc math result and alarm mode),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x01 \nwhich is the code for the LDC mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's from LDC mode\nif(msg.payload[1]!=0x01){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":430,"y":500,"wires":[["8b93cb85.d95b78"]]},{"id":"ac098eee.791c","type":"comment","z":"eaf85255.d8106","name":"Read me","info":"Company: BeanAir\nDate:  31/03/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in low duty cycle mode and display it in graph.\nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n    \nInformations we need:\n    LDCDA (Low Duty Cycle Data Acquisition) frame content:\n+(0)---------+(1)------+(2)--------+(3)------------+(7)---------+(10)\n|Device type |DAC type |Channel id |Reference time |Data sample |\n|(1 byte)    |(1 byte) |(1byte)    |(4 bytes)      |(3 bytes)   |\n+------------+---------+-----------+---------------+------------+\n\n(Note: \n    + Date time is in Unix format (LSB first)\n    + Data sample (LSB first), the last bit is a sign bit)\n    \nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference\ndocuement http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n\nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for static measurement of each channel\n3- Start running the beandevice in LDC mode\n\nSteps:\n1- connect to the broker\n2- subscribe to each sensor's static measurement topic\n3- wait for payloads\n4- check DAC type if it's LDC\n5- parse the coming payload\n6- display data in graph","x":80,"y":280,"wires":[]},{"id":"9ef1fdf0.166dc","type":"function","z":"eaf85255.d8106","name":"get_channelName","func":"var channelName = {}\nchannelName.topic = \"channelName\"\n\nswitch(msg.payload){\n    case 0x00:\n        channelName.payload = \"Ch_Z\"\n        break;\n    case 0x01:\n        channelName.payload = \"Ch_X\"\n        break;\n    case 0x02:\n        channelName.payload = \"Ch_Y\"\n        break;\n    case 0x03:\n        channelName.payload = \"Inc_X\"\n        break;\n    case 0x04:\n        channelName.payload = \"Inc_Y\"\n        break\n    default:\n        channelName.payload = \"Unknow\"\n        break;\n}\n\nreturn channelName;","outputs":1,"noerr":0,"x":890,"y":500,"wires":[["207c4320.3de5fc"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"e86d16a4.4d8228","type":"function","z":"eaf85255.d8106","name":"get_data","func":"// input\nvar dataHex = msg.payload\n// output\nvar data = {}\ndata.topic = \"data\"\n\n// measurement in 3 bytes , LSB first and last bit is a sign bit\n// convert hex to decimal\ndata.payload = 0x000000\ndata.payload |= dataHex[0]\ndata.payload |= (dataHex[1]<<8) \ndata.payload |= (dataHex[2]&0x7f<<16)\n\n//if sign bit equal 1 the measurement is negative\nif((dataHex[2]&0x80)==0x80){\n    data.payload *= -1\n}\n\n// divide data by 1000 to get the real measurement\ndata.payload = data.payload/1000\n\nreturn data;","outputs":1,"noerr":0,"x":860,"y":620,"wires":[["207c4320.3de5fc"]]},{"id":"464a9fba.9915","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/1)","topic":"F0B5D1A48F4E0000/SENSOR/1","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":440,"wires":[["134d2a15.d4f396"]]},{"id":"7e5b9df8.943994","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/2)","topic":"F0B5D1A48F4E0000/SENSOR/2","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":500,"wires":[["134d2a15.d4f396"]]},{"id":"b0741d11.19926","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/3)","topic":"F0B5D1A48F4E0000/SENSOR/3","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":560,"wires":[["134d2a15.d4f396"]]},{"id":"7e589961.70a4c8","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/4)","topic":"F0B5D1A48F4E0000/SENSOR/4","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":620,"wires":[["134d2a15.d4f396"]]},{"id":"683b459f.e2625c","type":"function","z":"eaf85255.d8106","name":"to inclinometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nfilter = \"inc\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedInclMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1390,"y":600,"wires":[["d16f5d66.0c632"]]},{"id":"5ab5d8b8.d82498","type":"mqtt-broker","z":"","name":"hivemq broker","broker":"broker.hivemq.com","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"5e904f96.9d93d","type":"ui_group","z":"eaf85255.d8106","name":"MQTT Low Duty Cycle","tab":"ec5520b0.8e798","disp":true,"width":"25","collapse":false},{"id":"ec5520b0.8e798","type":"ui_tab","z":"eaf85255.d8106","name":"BeanAir: Low Duty Cycle","icon":"dashboard","order":5,"disabled":false,"hidden":false}]
[{"id":"a24aab61.564278","type":"subflow","name":"Ldc Math Result","info":"","category":"","in":[{"x":80,"y":360,"wires":[{"id":"dd3e7473.3ceef8"}]}],"out":[{"x":1420,"y":240,"wires":[{"id":"7bf8b67b.86c548","port":0}]},{"x":1660,"y":360,"wires":[{"id":"7ca1796a.1ad2f8","port":0}]},{"x":1660,"y":500,"wires":[{"id":"dc833abf.1d2a98","port":0}]},{"x":1660,"y":640,"wires":[{"id":"b1afe423.6a3fb8","port":0}]},{"x":700,"y":720,"wires":[{"id":"b8dda9a2.637f38","port":0}]}],"env":[],"color":"#DDAA99"},{"id":"218ef623.7d97ca","type":"function","z":"a24aab61.564278","name":"parsing","func":"// Decalre variable for each object we need from the MQTT frame\nvar deviceType = {}\nvar dacType = {}\nvar channelId = {}\nvar mathResultId = {}\nvar eventTime = {}\nvar startTime = {}\nvar endTime = {}\nvar data = {}\n\n/*******************************/\n/* Parsing the LDC Math Result frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// channel id\nchannelId.payload = msg.payload[2]\n\n// math result id (type)\nmathResultId.payload = msg.payload[3]\n\n// Event time (in Unix format) (4 bytes) \neventTime.payload = []\nfor(i=0; i<4; i++){\n    eventTime.payload[i] = msg.payload[4+i]\n}\n\n// Start time (in Unix format) (4 bytes) \nstartTime.payload = []\nfor(i=0; i<4; i++){\n    startTime.payload[i] = msg.payload[8+i]\n}\n\n// End time (in Unix format) (4 bytes) \nendTime.payload = []\nfor(i=0; i<4; i++){\n    endTime.payload[i] = msg.payload[12+i]\n}   \n\n// data in 3 bytes\ndata.payload = []\nfor(i=0; i<3; i++){\n    data.payload[i] = msg.payload[16+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, data , mathResultId, eventTime, startTime, endTime, channelId]","outputs":8,"noerr":0,"x":300,"y":500,"wires":[["314c97f9.63b768"],["eb12c7f7.b649b8"],["61bba345.dbfe9c"],["eea1f26f.a0865"],["5452cf1c.c5913"],["e47206d6.ebae88"],["90958f34.fc682"],["b8dda9a2.637f38"]]},{"id":"314c97f9.63b768","type":"function","z":"a24aab61.564278","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":520,"y":240,"wires":[["7bf8b67b.86c548"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"eb12c7f7.b649b8","type":"function","z":"a24aab61.564278","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":520,"y":300,"wires":[["7bf8b67b.86c548"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"5452cf1c.c5913","type":"function","z":"a24aab61.564278","name":"get-eventTimestamp","func":"var eventTimestamp = {}\neventTimestamp.topic = \"eventTimestamp\"\n\n// timestamp\neventTimestamp.payload = 0x00000000\neventTimestamp.payload |= msg.payload[0]\neventTimestamp.payload |= msg.payload[1]<<8\neventTimestamp.payload |= msg.payload[2]<<16\neventTimestamp.payload |= msg.payload[3]<<24\n\n\nreturn eventTimestamp;","outputs":1,"noerr":0,"x":540,"y":520,"wires":[["91c3f6fe.a989e8"]]},{"id":"7bf8b67b.86c548","type":"join","z":"a24aab61.564278","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":850,"y":240,"wires":[[]]},{"id":"b8dda9a2.637f38","type":"function","z":"a24aab61.564278","name":"get_channelName","func":"var channelName = {}\nchannelName.topic = \"channelName\"\n\nswitch(msg.payload){\n    case 0x00:\n        channelName.payload = \"Ch_Z\"\n        break;\n    case 0x01:\n        channelName.payload = \"Ch_X\"\n        break;\n    case 0x02:\n        channelName.payload = \"Ch_Y\"\n        break;\n    case 0x03:\n        channelName.payload = \"Inc_X\"\n        break;\n    case 0x04:\n        channelName.payload = \"Inc_Y\"\n        break\n    default:\n        channelName.payload = \"Unknow\"\n        break;\n}\n\nreturn channelName;","outputs":1,"noerr":0,"x":530,"y":720,"wires":[[]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"61bba345.dbfe9c","type":"function","z":"a24aab61.564278","name":"get_data","func":"// input\nvar dataHex = msg.payload\n// output\nvar data = {}\ndata.topic = \"data\"\n\n// measurement in 3 bytes , LSB first and last bit is a sign bit\n// convert hex to decimal\ndata.payload = 0x000000\ndata.payload |= dataHex[0]\ndata.payload |= (dataHex[1]<<8) \ndata.payload |= (dataHex[2]&0x7f<<16)\n\n//if sign bit equal 1 the measurement is negative\nif((dataHex[2]&0x80)==0x80){\n    data.payload *= -1\n}\n\n// divide data by 1000 to get the real measurement\ndata.payload = data.payload/1000\n\nreturn data;","outputs":1,"noerr":0,"x":520,"y":380,"wires":[["6ead3c1f.5537d4"]]},{"id":"eea1f26f.a0865","type":"function","z":"a24aab61.564278","name":"get_mathResultType","func":"var mathResultType = {}\nmathResultType.topic = \"mathResultType\"\n\nswitch(msg.payload){\n    case 0x01:\n        mathResultType.payload = \"Maximum\"\n        break;\n    case 0x02:\n        mathResultType.payload = \"Minimum\"\n        break;\n    case 0x03:\n        mathResultType.payload = \"Average\"\n        break;\n    default:\n        mathResultType.payload = \"Unknow\"\n        break;\n}\n\nreturn mathResultType;","outputs":1,"noerr":0,"x":540,"y":460,"wires":[["91c3f6fe.a989e8","6ead3c1f.5537d4"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"e47206d6.ebae88","type":"function","z":"a24aab61.564278","name":"get-startTimestamp","func":"var startTimestamp = {}\nstartTimestamp.topic = \"startTimestamp\"\n\n// timestamp\nstartTimestamp.payload = 0x00000000\nstartTimestamp.payload |= msg.payload[0]\nstartTimestamp.payload |= msg.payload[1]<<8\nstartTimestamp.payload |= msg.payload[2]<<16\nstartTimestamp.payload |= msg.payload[3]<<24\n\nreturn startTimestamp;","outputs":1,"noerr":0,"x":530,"y":580,"wires":[["91c3f6fe.a989e8"]]},{"id":"90958f34.fc682","type":"function","z":"a24aab61.564278","name":"get-endTimestamp","func":"var endTimestamp = {}\nendTimestamp.topic = \"endTimestamp\"\n\n// timestamp\nendTimestamp.payload = 0x00000000\nendTimestamp.payload |= msg.payload[0]\nendTimestamp.payload |= msg.payload[1]<<8\nendTimestamp.payload |= msg.payload[2]<<16\nendTimestamp.payload |= msg.payload[3]<<24\n\nreturn endTimestamp;","outputs":1,"noerr":0,"x":530,"y":620,"wires":[["91c3f6fe.a989e8"]]},{"id":"a288c1ad.3c5b7","type":"function","z":"a24aab61.564278","name":"select time converter","func":"// this function will return the timestamp depends on the math result type\n// if math result type is average then return start and end timestamps\n// if math result type is minimum or maximum then return only the event timestamp\n\n// input\nvar mathResultType = msg.payload.mathResultType\nvar eventTimestamp = msg.payload.eventTimestamp\nvar startTimestamp = msg.payload.startTimestamp\nvar endTimestamp = msg.payload.endTimestamp\n\n// output\n// time structon is [eventtimestamp for maximum value, eventtimestamp for minimum value, startTimestamp, endTimestamp]\nvar time = [null, null, null, null]\n\nif(mathResultType==\"Maximum\"){\n    time[0] = {}\n    time[0].payload = eventTimestamp.toString()\n}\nelse if(mathResultType==\"Minimum\"){\n    time[1] = {}\n    time[1].payload = eventTimestamp.toString()\n}\nelse if(mathResultType==\"Average\"){\n    time[2] = {}\n    time[2].payload = startTimestamp.toString()\n    time[3] = {}\n    time[3].payload = endTimestamp.toString()\n}\n\nreturn time;","outputs":4,"noerr":0,"x":960,"y":620,"wires":[["5ea72cda.164f94"],["f00f08b5.851338"],["8d3962e2.a0a9c"],["8ece34bb.115898"]]},{"id":"5ea72cda.164f94","type":"moment","z":"a24aab61.564278","name":"max event time","topic":"maxEventTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1200,"y":520,"wires":[["a40df951.e6c6c8"]]},{"id":"8d3962e2.a0a9c","type":"moment","z":"a24aab61.564278","name":"start time","topic":"startTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1180,"y":600,"wires":[["534d52c5.78165c"]]},{"id":"8ece34bb.115898","type":"moment","z":"a24aab61.564278","name":"end time","topic":"endTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1180,"y":640,"wires":[["534d52c5.78165c"]]},{"id":"91c3f6fe.a989e8","type":"join","z":"a24aab61.564278","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"4","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":770,"y":620,"wires":[["a288c1ad.3c5b7"]]},{"id":"f00f08b5.851338","type":"moment","z":"a24aab61.564278","name":"min event time","topic":"minEventTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1200,"y":560,"wires":[["37347381.b212bc"]]},{"id":"6ead3c1f.5537d4","type":"join","z":"a24aab61.564278","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":770,"y":380,"wires":[["5f85c782.eff2f8"]]},{"id":"5f85c782.eff2f8","type":"function","z":"a24aab61.564278","name":"data separator","func":"\n// input\nvar mathResultType = msg.payload.mathResultType\nvar data = msg.payload.data\n\n// output\nvar output = [null, null, null]\n\nif(mathResultType==\"Maximum\"){\n    output[0] = {}\n    output[0].topic = \"maxValue\"\n    output[0].payload = data\n}\nelse if(mathResultType==\"Minimum\"){\n    output[1] = {}\n    output[1].topic = \"minValue\"\n    output[1].payload = data\n}\nelse if(mathResultType==\"Average\"){\n    output[2] = {}\n    output[2].topic = \"avgValue\"\n    output[2].payload = data\n}\n\nreturn output;","outputs":3,"noerr":0,"x":1180,"y":380,"wires":[["a40df951.e6c6c8"],["37347381.b212bc"],["534d52c5.78165c"]]},{"id":"534d52c5.78165c","type":"join","z":"a24aab61.564278","name":"Avg join","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1400,"y":640,"wires":[["b1afe423.6a3fb8"]]},{"id":"a40df951.e6c6c8","type":"join","z":"a24aab61.564278","name":"Max join","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":1400,"y":360,"wires":[["7ca1796a.1ad2f8"]]},{"id":"37347381.b212bc","type":"join","z":"a24aab61.564278","name":"Min join","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1400,"y":500,"wires":[["dc833abf.1d2a98"]]},{"id":"7ca1796a.1ad2f8","type":"change","z":"a24aab61.564278","name":"Max","rules":[{"t":"set","p":"topic","pt":"msg","to":"max","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1530,"y":360,"wires":[[]]},{"id":"dc833abf.1d2a98","type":"change","z":"a24aab61.564278","name":"Min","rules":[{"t":"set","p":"topic","pt":"msg","to":"min","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1530,"y":500,"wires":[[]]},{"id":"b1afe423.6a3fb8","type":"change","z":"a24aab61.564278","name":"Avg","rules":[{"t":"set","p":"topic","pt":"msg","to":"avg","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1530,"y":640,"wires":[[]]},{"id":"dd3e7473.3ceef8","type":"function","z":"a24aab61.564278","name":"MQTT frame verification","func":"/*\nBecause the Static topic is not reserved only for Alarm mode data\n(shared with LDC mode and ldc math result),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x02 \nwhich is the code for the Alarm mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's from Alarm mode\nif(msg.payload[1]!=0x05){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":900,"wires":[["218ef623.7d97ca"]]}]
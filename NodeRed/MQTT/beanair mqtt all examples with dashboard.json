[{"id":"ea614234.df4b8","type":"tab","label":"MQTT Client for Streaming 31_03_2020","disabled":false,"info":""},{"id":"7fdfc2f.0fa413c","type":"tab","label":"MQTT Client for SET 02_04_2020","disabled":false,"info":""},{"id":"19e325ac.ee4faa","type":"tab","label":"MQTT Client for Shock Detection 02_04_2020","disabled":false,"info":""},{"id":"eaf85255.d8106","type":"tab","label":"MQTT Client for LDC 31_03_2020","disabled":false,"info":""},{"id":"53382208.28f12c","type":"tab","label":"MQTT Client for Alarm 1_4_2020","disabled":false,"info":""},{"id":"d133d0a9.0850c","type":"tab","label":"MQTT Client for LDC Math Result 03_03_2020 v1","disabled":false,"info":""},{"id":"a24aab61.564278","type":"subflow","name":"Ldc Math Result","info":"","category":"","in":[{"x":80,"y":360,"wires":[{"id":"dd3e7473.3ceef8"}]}],"out":[{"x":1420,"y":240,"wires":[{"id":"7bf8b67b.86c548","port":0}]},{"x":1660,"y":360,"wires":[{"id":"7ca1796a.1ad2f8","port":0}]},{"x":1660,"y":500,"wires":[{"id":"dc833abf.1d2a98","port":0}]},{"x":1660,"y":640,"wires":[{"id":"b1afe423.6a3fb8","port":0}]},{"x":700,"y":720,"wires":[{"id":"b8dda9a2.637f38","port":0}]}],"env":[],"color":"#DDAA99"},{"id":"5ab5d8b8.d82498","type":"mqtt-broker","z":"","name":"hivemq broker","broker":"broker.hivemq.com","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"eb49f40e.08a888","type":"ui_base","theme":{"name":"theme-dark","lightTheme":{"default":"#0094CE","baseColor":"#0094CE","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"darkTheme":{"default":"#097479","baseColor":"#097479","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"customTheme":{"name":"Untitled Theme 1","default":"#4B7930","baseColor":"#4B7930","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"},"themeState":{"base-color":{"default":"#097479","value":"#097479","edited":false},"page-titlebar-backgroundColor":{"value":"#097479","edited":false},"page-backgroundColor":{"value":"#111111","edited":false},"page-sidebar-backgroundColor":{"value":"#000000","edited":false},"group-textColor":{"value":"#0eb8c0","edited":false},"group-borderColor":{"value":"#555555","edited":false},"group-backgroundColor":{"value":"#333333","edited":false},"widget-textColor":{"value":"#eeeeee","edited":false},"widget-backgroundColor":{"value":"#097479","edited":false},"widget-borderColor":{"value":"#333333","edited":false},"base-font":{"value":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"}},"angularTheme":{"primary":"indigo","accents":"blue","warn":"red","background":"grey"}},"site":{"name":"Node-RED Dashboard","hideToolbar":"false","allowSwipe":"false","lockMenu":"false","allowTempTheme":"true","dateFormat":"DD/MM/YYYY z+0","sizes":{"sx":48,"sy":48,"gx":6,"gy":6,"cx":6,"cy":6,"px":0,"py":0}}},{"id":"82a1ef24.b8612","type":"ui_group","z":"ea614234.df4b8","name":"MQTT Streaming","tab":"c73c6760.32bfa8","order":1,"disp":true,"width":"25","collapse":false},{"id":"c73c6760.32bfa8","type":"ui_tab","z":"ea614234.df4b8","name":"BeanAir: Streaming","icon":"dashboard","order":4,"disabled":false,"hidden":false},{"id":"5e904f96.9d93d","type":"ui_group","z":"eaf85255.d8106","name":"MQTT Low Duty Cycle","tab":"ec5520b0.8e798","disp":true,"width":"25","collapse":false},{"id":"ec5520b0.8e798","type":"ui_tab","z":"eaf85255.d8106","name":"BeanAir: Low Duty Cycle","icon":"dashboard","order":1,"disabled":false,"hidden":false},{"id":"af71a73e.e1d838","type":"ui_group","z":"53382208.28f12c","name":"MQTT Alarm","tab":"e3e4f23f.762d2","order":1,"disp":true,"width":"25","collapse":false},{"id":"e3e4f23f.762d2","type":"ui_tab","z":"53382208.28f12c","name":"BeanAir: Alarm","icon":"dashboard","order":3,"disabled":false,"hidden":false},{"id":"383f877f.d06d48","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":3,"width":1,"height":1},{"id":"771b14c6.70db4c","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":5,"width":1,"height":1},{"id":"1990f6ae.4ef439","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":6,"width":1,"height":1},{"id":"27757894.d5e5f8","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":7,"width":1,"height":1},{"id":"356dc017.db34e","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":8,"width":1,"height":1},{"id":"1961d417.d9694c","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":9,"width":1,"height":1},{"id":"3a1b0c2c.f40144","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":13,"width":2,"height":1},{"id":"ddb9a1fd.a9174","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":15,"width":2,"height":1},{"id":"3a0f01bc.21b00e","type":"ui_spacer","name":"spacer","group":"af71a73e.e1d838","order":17,"width":1,"height":1},{"id":"ef1869fd.367b78","type":"ui_group","z":"19e325ac.ee4faa","name":"MQTT Shock Detection","tab":"43c22f6b.2e6ec","order":1,"disp":true,"width":"25","collapse":false},{"id":"43c22f6b.2e6ec","type":"ui_tab","z":"19e325ac.ee4faa","name":"BeanAir: Shock Detection","icon":"dashboard","order":6,"disabled":false,"hidden":false},{"id":"8e61f90c.a805c8","type":"ui_spacer","name":"spacer","group":"ef1869fd.367b78","order":3,"width":1,"height":1},{"id":"c2c2ef02.e2c1b","type":"ui_spacer","name":"spacer","group":"ef1869fd.367b78","order":5,"width":1,"height":1},{"id":"a57207d3.fcfd68","type":"ui_spacer","name":"spacer","group":"ef1869fd.367b78","order":6,"width":1,"height":1},{"id":"7bebe639.3a8e48","type":"ui_spacer","name":"spacer","group":"ef1869fd.367b78","order":7,"width":1,"height":1},{"id":"96fcd691.33b378","type":"ui_spacer","name":"spacer","group":"ef1869fd.367b78","order":8,"width":1,"height":1},{"id":"d385f87d.51f6f8","type":"ui_spacer","name":"spacer","group":"ef1869fd.367b78","order":9,"width":1,"height":1},{"id":"b2661d4d.1e592","type":"ui_group","z":"7fdfc2f.0fa413c","name":"MQTT SET","tab":"84b79662.d3a428","order":1,"disp":true,"width":"25","collapse":false},{"id":"84b79662.d3a428","type":"ui_tab","z":"7fdfc2f.0fa413c","name":"BeanAir: SET","icon":"dashboard","order":5,"disabled":false,"hidden":false},{"id":"b5624df3.b5a46","type":"mqtt-broker","z":"","name":"local broker","broker":"192.168.1.40","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"e5de774b.023f68","type":"ui_group","z":"","name":"MQTT static math result","tab":null,"order":1,"disp":true,"width":27,"collapse":false},{"id":"4fc393c.6feac6c","type":"ui_group","name":"Group 2","tab":null,"order":3,"disp":true,"width":10},{"id":"a6ec1fb3.340a5","type":"ui_group","name":"Group 4","tab":null,"order":5,"disp":true,"width":10},{"id":"822662bf.ecbca","type":"ui_group","name":"Group 5","tab":null,"order":6,"disp":true,"width":10},{"id":"bb81dab5.ec3ff8","type":"ui_group","z":"","name":"Group 1","tab":null,"order":2,"disp":true,"width":10,"collapse":false},{"id":"871e25e0.0990c8","type":"ui_group","z":"","name":"Z channel","tab":null,"order":2,"disp":true,"width":"9","collapse":true},{"id":"8a57308a.e7cc4","type":"ui_group","z":"","name":"X channel","tab":null,"order":3,"disp":true,"width":"9","collapse":true},{"id":"f32587fc.e602c8","type":"ui_group","z":"","name":"Y channel","tab":null,"order":4,"disp":true,"width":"9","collapse":false},{"id":"51834252.920ffc","type":"ui_group","z":"","name":"X Inclinometer","tab":null,"order":5,"disp":true,"width":"13","collapse":false},{"id":"76429baa.51dbe4","type":"ui_group","z":"","name":"Y Inclinometer","tab":null,"order":6,"disp":true,"width":"13","collapse":false},{"id":"f64466cc.012f78","type":"ui_spacer","name":"spacer","group":"871e25e0.0990c8","order":3,"width":9,"height":1},{"id":"3de08db0.32e072","type":"ui_spacer","name":"spacer","group":"871e25e0.0990c8","order":6,"width":9,"height":1},{"id":"c36c6811.ce60e8","type":"ui_spacer","name":"spacer","group":"871e25e0.0990c8","order":8,"width":9,"height":1},{"id":"a663fd.554bfc","type":"ui_spacer","name":"spacer","group":"871e25e0.0990c8","order":10,"width":1,"height":1},{"id":"2d72fbde.43b0a4","type":"ui_spacer","name":"spacer","group":"8a57308a.e7cc4","order":3,"width":9,"height":1},{"id":"87384956.5256d8","type":"ui_spacer","name":"spacer","group":"8a57308a.e7cc4","order":6,"width":9,"height":1},{"id":"5b955be4.63e374","type":"ui_spacer","name":"spacer","group":"8a57308a.e7cc4","order":8,"width":9,"height":1},{"id":"23155200.4d44be","type":"ui_spacer","name":"spacer","group":"8a57308a.e7cc4","order":10,"width":1,"height":1},{"id":"7c27d809.d3b4d8","type":"ui_spacer","name":"spacer","group":"f32587fc.e602c8","order":3,"width":9,"height":1},{"id":"4134423c.cc944c","type":"ui_spacer","name":"spacer","group":"f32587fc.e602c8","order":6,"width":9,"height":1},{"id":"d984adc9.54ce1","type":"ui_spacer","name":"spacer","group":"f32587fc.e602c8","order":8,"width":9,"height":1},{"id":"7f019dcf.e37b04","type":"ui_spacer","name":"spacer","group":"f32587fc.e602c8","order":10,"width":1,"height":1},{"id":"2898111d.124c6e","type":"ui_spacer","name":"spacer","group":"51834252.920ffc","order":2,"width":1,"height":1},{"id":"70956c4e.a90144","type":"ui_spacer","name":"spacer","group":"51834252.920ffc","order":4,"width":13,"height":1},{"id":"a333d7f6.d9d998","type":"ui_spacer","name":"spacer","group":"51834252.920ffc","order":6,"width":1,"height":1},{"id":"7bbf5a9.3293da4","type":"ui_spacer","name":"spacer","group":"51834252.920ffc","order":8,"width":13,"height":1},{"id":"2b612920.a750d6","type":"ui_spacer","name":"spacer","group":"51834252.920ffc","order":10,"width":13,"height":1},{"id":"a86ae509.b7f4c8","type":"ui_spacer","name":"spacer","group":"51834252.920ffc","order":12,"width":1,"height":1},{"id":"4c40899f.49c7b8","type":"ui_spacer","name":"spacer","group":"76429baa.51dbe4","order":2,"width":1,"height":1},{"id":"f776c026.c246a","type":"ui_spacer","name":"spacer","group":"76429baa.51dbe4","order":4,"width":13,"height":1},{"id":"2174d135.64157e","type":"ui_spacer","name":"spacer","group":"76429baa.51dbe4","order":6,"width":1,"height":1},{"id":"6df37d78.741b54","type":"ui_spacer","name":"spacer","group":"76429baa.51dbe4","order":8,"width":13,"height":1},{"id":"cebda104.a5989","type":"ui_spacer","name":"spacer","group":"76429baa.51dbe4","order":10,"width":13,"height":1},{"id":"96c46c6b.7efea","type":"ui_spacer","name":"spacer","group":"76429baa.51dbe4","order":12,"width":1,"height":1},{"id":"94a9becc.fcf65","type":"ui_tab","z":"d133d0a9.0850c","name":"BeanAir: MQTT LDC Math Result","icon":"dashboard","order":2,"disabled":false,"hidden":false},{"id":"f6818abe.1b0bd8","type":"ui_group","z":"","name":"Channel Z","tab":"94a9becc.fcf65","order":2,"disp":true,"width":8,"collapse":false},{"id":"fe2e106f.0b6b1","type":"ui_group","z":"","name":"Channel X","tab":"94a9becc.fcf65","order":3,"disp":true,"width":8,"collapse":false},{"id":"ef404540.ad5738","type":"ui_group","z":"","name":"Channel Y","tab":"94a9becc.fcf65","order":4,"disp":true,"width":8,"collapse":false},{"id":"65741de5.2a6734","type":"ui_group","z":"","name":"Inclinometer X","tab":"94a9becc.fcf65","order":5,"disp":true,"width":12,"collapse":false},{"id":"20f4c874.ca2f18","type":"ui_group","z":"","name":"Inclinometer Y","tab":"94a9becc.fcf65","order":6,"disp":true,"width":12,"collapse":false},{"id":"daffd0a1.a46a8","type":"ui_group","z":"","name":"Z Channel","tab":"","order":1,"disp":true,"width":"6","collapse":false},{"id":"deb43774.59f608","type":"ui_group","name":"Group 2","tab":null,"order":2,"disp":true,"width":6},{"id":"75ebb2e3.cac28c","type":"ui_group","name":"Group 3","tab":null,"order":3,"disp":true,"width":6},{"id":"2abead04.983b92","type":"ui_group","name":"Group 4","tab":null,"order":4,"disp":true,"width":6},{"id":"b8b05fd0.122eb","type":"ui_group","name":"Group 5","tab":null,"order":5,"disp":true,"width":6},{"id":"d146ea63.433e48","type":"ui_group","z":"","name":"Z channel","tab":"","order":1,"disp":true,"width":"6","collapse":false},{"id":"7a720249.7a301c","type":"ui_group","name":"Group 2","tab":null,"order":2,"disp":true,"width":6},{"id":"7bfb45a2.23f4cc","type":"ui_group","name":"Group 3","tab":null,"order":3,"disp":true,"width":6},{"id":"2ba18a55.25f936","type":"ui_group","name":"Group 4","tab":null,"order":4,"disp":true,"width":6},{"id":"644ef5c4.76c54c","type":"ui_group","name":"Group 5","tab":null,"order":5,"disp":true,"width":6},{"id":"1f3e213e.db5b1f","type":"ui_group","z":"","name":"Z channel","tab":"f2eeac05.5ed47","order":3,"disp":true,"width":"6","collapse":false},{"id":"9b17d325.9d467","type":"ui_group","z":"","name":"X channel","tab":"f2eeac05.5ed47","order":4,"disp":true,"width":"6","collapse":false},{"id":"517b70bd.4fb42","type":"ui_group","z":"","name":"X inclinometer","tab":"f2eeac05.5ed47","order":5,"disp":true,"width":"6","collapse":false},{"id":"c637bc13.82ce5","type":"ui_group","z":"","name":"Y Inclinometer","tab":"f2eeac05.5ed47","order":5,"disp":true,"width":"6","collapse":false},{"id":"158893dd.30fb5c","type":"ui_group","z":"","name":"Header","tab":"94a9becc.fcf65","order":1,"disp":false,"width":"24","collapse":false},{"id":"762e47b9.263da8","type":"ui_spacer","name":"spacer","group":"f6818abe.1b0bd8","order":3,"width":8,"height":1},{"id":"5f936c69.10f574","type":"ui_spacer","name":"spacer","group":"f6818abe.1b0bd8","order":6,"width":8,"height":1},{"id":"956be57a.1848d8","type":"ui_spacer","name":"spacer","group":"fe2e106f.0b6b1","order":3,"width":8,"height":1},{"id":"acb7dccc.f1a92","type":"ui_spacer","name":"spacer","group":"fe2e106f.0b6b1","order":6,"width":8,"height":1},{"id":"3eaa280f.ad70c8","type":"ui_spacer","name":"spacer","group":"ef404540.ad5738","order":3,"width":8,"height":1},{"id":"6ef5f5fa.619a7c","type":"ui_spacer","name":"spacer","group":"ef404540.ad5738","order":6,"width":8,"height":1},{"id":"2306bee7.8f8f82","type":"ui_spacer","name":"spacer","group":"65741de5.2a6734","order":3,"width":12,"height":1},{"id":"19b682a9.7227fd","type":"ui_spacer","name":"spacer","group":"65741de5.2a6734","order":6,"width":12,"height":1},{"id":"a13d1137.79233","type":"ui_spacer","name":"spacer","group":"20f4c874.ca2f18","order":3,"width":12,"height":1},{"id":"a526ce3b.b4dcc","type":"ui_spacer","name":"spacer","group":"20f4c874.ca2f18","order":6,"width":12,"height":1},{"id":"2a1fb8df.da04f8","type":"mqtt in","z":"ea614234.df4b8","name":"Broker","topic":"F0B5D1A48F4E0000/STREAMING","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":70,"y":500,"wires":[["84e242b3.d62da"]]},{"id":"b2ca74c0.20f0c8","type":"function","z":"ea614234.df4b8","name":"parsing","func":"// Decalre variable for each object we need from the streaming frame\nvar deviceType = {}\nvar dacType = {}\nvar time = {}\nvar samplingRate = {}\nvar channelsBitmap = {}\nvar frameId = {}\nvar numberDacPerChannel = {}\nvar previousNumberDacPerChannel = {}\nvar syncronizationStatus = {}\nvar data = {}\ndata.topic = \"data\"\n\n// local variable\nvar i // for the for statement\nvar dataLen // for the total number of measurements\n\n/*******************************/\n/* Parsing the streaming frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// timestamp and milliseconds\n// The time in the streaming mode frame in 6 bytes.\n// 4 bytes for the Reference time in Unix format)\n// 2 byte for the Reference millisecond\ntime.payload = {}\nfor(i=0; i<6; i++){\n    time.payload[i] = msg.payload[2+i]\n}\n// The sampling rate in 2 bytes\nsamplingRate.payload = {}\nfor(i=0; i<2; i++){\n    samplingRate.payload[i] = msg.payload[8+i]\n}\n// The channels bitmap is in 4 bytes\nchannelsBitmap.payload = {}\nfor(i=0; i<4; i++){\n    channelsBitmap.payload[i] = msg.payload[10+i]\n}\n// The frame Id in 3 byte\nframeId.payload = {}\nfor(i=0; i<3; i++){\n    frameId.payload[i] = msg.payload[14+i]\n}\n// The current number of samples per channel in 2 bytes\nnumberDacPerChannel.payload = {}\nfor(i=0; i<2; i++){\n    numberDacPerChannel.payload[i] = msg.payload[17+i]\n}\n// The previous number of samples per channel in 2 bytes\npreviousNumberDacPerChannel.payload = {}\nfor(i=0; i<2; i++){\n    previousNumberDacPerChannel.payload[i] = msg.payload[25+i]\n}\n\n// the syncronization status\nsyncronizationStatus.payload = msg.payload[27]\n        \n// The data (or measurements) is the rest of the payload\n// stream frame length - the header length (fixed objects) or multiply the number of samples by the number of active channels\ndataLen = msg.payload.length - 29\ndata.payload = []\nfor(i=0; i<dataLen; i++){\n    data.payload[i] = msg.payload[29+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, syncronizationStatus, channelsBitmap, data, numberDacPerChannel, previousNumberDacPerChannel, frameId, time, samplingRate]","outputs":10,"noerr":0,"x":480,"y":500,"wires":[["eb08c8e7.cf88b8"],["5892fc03.484604"],["fe861db1.2d429"],["d97597d.0cd1268"],["4d610a00.44b2b8"],["aa0fc702.d01ce8"],["883c4572.1dcac8"],["b1d25d42.deaf5"],["bff383d6.2c24d"],["9ae099a7.bf45c8"]]},{"id":"eb08c8e7.cf88b8","type":"function","z":"ea614234.df4b8","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":760,"y":280,"wires":[["23c2b893.49de98"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"5892fc03.484604","type":"function","z":"ea614234.df4b8","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":760,"y":340,"wires":[["23c2b893.49de98"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"d97597d.0cd1268","type":"function","z":"ea614234.df4b8","name":"get_channels","func":"/*\nthe channel bitmap is 4 bytes.\neach bit represent one channel status:\n    0 mean that channel is disable,\n    1 mean that channel enabel\nand from the bit index we can get the channel name\n*/\n\nvar channelsList=[]\nvar indexPos = 0;\nvar bitPos = 1\nvar i;\nfor(i=0; i<4; i++){\n    bitPos = 1\n    while(bitPos<=0x10){\n        if(msg.payload[i]&bitPos){\n            if(indexPos==0x00)\n                channelsList.push(\"Ch_Z\")\n            else if(indexPos==0x01)\n                channelsList.push(\"Ch_X\")\n            else if(indexPos==0x02)\n                channelsList.push(\"Ch_Y\")\n            else if(indexPos==0x03)\n                channelsList.push(\"Inc_X\")\n            else if(indexPos==0x04)\n                channelsList.push(\"Inc_Y\")\n        }\n        bitPos<<=1\n        indexPos+=1\n    }\n}\nmsg.payload = channelsList\nmsg.topic = \"channelsList\"\nreturn msg;","outputs":1,"noerr":0,"x":750,"y":460,"wires":[["4d610a00.44b2b8","578b4041.a5518"]]},{"id":"bff383d6.2c24d","type":"function","z":"ea614234.df4b8","name":"get-timestampAndMs","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timeStamp\"\nvar time_ms = {}\ntime_ms.topic = \"time_ms\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n// milliseconds\ntime_ms.payload = 0x0000\ntime_ms.payload |= msg.payload[4]\ntime_ms.payload |= msg.payload[5]<<8\n\nreturn [time_timeStamp, time_ms];","outputs":2,"noerr":0,"x":780,"y":780,"wires":[["f89ff35e.dadc"],["f89ff35e.dadc"]]},{"id":"e805e6b4.dac418","type":"function","z":"ea614234.df4b8","name":"get_dateTimeArray","func":"// input\nvar time_timeStamp = msg.payload.time_timeStamp\nvar time_ms = msg.payload.time_ms\nvar samplingRate = msg.payload.samplingRate\nvar frameId = msg.payload.frameId\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar previouseNbrDataPerChannel = msg.payload.previouseNbrDataPerChannel\n// output\nvar dataTimeArray = {}\ndataTimeArray.topic = \"dataTimeArray\"\n\ndataTimeArray.payload = []\nvar subPacketRow = 0\nfor(subPacketRow=0; subPacketRow<currentNbrDataPerChannel;subPacketRow++){\n    var subPacketIndex = (frameId * previouseNbrDataPerChannel) + subPacketRow\n    dataTimeArray.payload.push(time_timeStamp+time_ms/1000+((1/samplingRate)*subPacketIndex))\n}\nreturn dataTimeArray;","outputs":1,"noerr":0,"x":1330,"y":720,"wires":[["578b4041.a5518"]]},{"id":"f89ff35e.dadc","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"6","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":720,"wires":[["e805e6b4.dac418"]]},{"id":"b1d25d42.deaf5","type":"function","z":"ea614234.df4b8","name":"get_frameId","func":"//frame id in 3 bytes\nvar frameId = {}\nframeId.topic = \"frameId\"\n\nframeId.payload = 0x000000\nframeId.payload |= msg.payload[0]\nframeId.payload |= msg.payload[1]<<8\nframeId.payload |= msg.payload[2]<<16\n\nreturn frameId;","outputs":1,"noerr":0,"x":750,"y":720,"wires":[["f89ff35e.dadc","e63e1fe.0c727e"]]},{"id":"9ae099a7.bf45c8","type":"function","z":"ea614234.df4b8","name":"get_samplingRate","func":"//sampling rate in 2 bytes\nvar samplingRate = {}\nsamplingRate.topic = \"samplingRate\"\n\nsamplingRate.payload = 0x000000\nsamplingRate.payload |= msg.payload[0]\nsamplingRate.payload |= msg.payload[1]<<8\n\nreturn samplingRate;","outputs":1,"noerr":0,"x":770,"y":840,"wires":[["f89ff35e.dadc"]]},{"id":"aa0fc702.d01ce8","type":"function","z":"ea614234.df4b8","name":"get_currentNbrDataPerChannel","func":"//current number of data per channel in 2 bytes\nvar currentNbrDataPerChannel = {}\ncurrentNbrDataPerChannel.topic = \"currentNbrDataPerChannel\"\n\ncurrentNbrDataPerChannel.payload = 0x000000\ncurrentNbrDataPerChannel.payload |= msg.payload[0]\ncurrentNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn currentNbrDataPerChannel;","outputs":1,"noerr":0,"x":810,"y":540,"wires":[["f89ff35e.dadc","4d610a00.44b2b8"]]},{"id":"883c4572.1dcac8","type":"function","z":"ea614234.df4b8","name":"get_previouseNbrDataPerChannel","func":"//previouse number of data per channel in 2 bytes\nvar previouseNbrDataPerChannel = {}\npreviouseNbrDataPerChannel.topic = \"previouseNbrDataPerChannel\"\n\npreviouseNbrDataPerChannel.payload = 0x000000\npreviouseNbrDataPerChannel.payload |= msg.payload[0]\npreviouseNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn previouseNbrDataPerChannel;","outputs":1,"noerr":0,"x":820,"y":600,"wires":[["f89ff35e.dadc"]]},{"id":"3a941c32.148ad4","type":"function","z":"ea614234.df4b8","name":"get_dataArray","func":"// input\nvar data = msg.payload.data\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar nbrChannels = (msg.payload.channelsList).length\n// output\nvar dataArray = {}\ndataArray.topic = \"dataArray\"\n/* out put struction */\n/*\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 0 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 1 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n.\n.\n.\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel m | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n\n2 dimensional array\nfirst dimension for channels\nsecond dimension for data of each channel\n\n*/\n// indexs\nvar i=0 // for the number of channels\nvar j=0 // for the current number of data per channel\nvar pos=0 // to keep track of the index of data\n\ndataArray.payload = new Array(nbrChannels)\nfor(i=0; i<nbrChannels; i++){\n    dataArray.payload[i] = new Array(currentNbrDataPerChannel)\n    for(j=0; j<currentNbrDataPerChannel; j++){\n        pos = i*3+j*nbrChannels*3\n        // sample in 3 bytes (signed and LSB)\n        dataArray.payload[i][j] = 0x000000\n        dataArray.payload[i][j] |= data[pos]\n        dataArray.payload[i][j] |= (data[pos+1]<<8) \n        dataArray.payload[i][j] |= (data[pos+2]&0x7f<<16)\n        dataArray.payload[i][j] = dataArray.payload[i][j]/1000\n        //if sign bit equal 1 the measurement is negative\n        if((data[pos+2]&0x80)==0x80){\n            dataArray.payload[i][j] *= -1\n        }\n    }\n}\n\nreturn dataArray;","outputs":1,"noerr":0,"x":1320,"y":500,"wires":[["578b4041.a5518"]]},{"id":"4d610a00.44b2b8","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":500,"wires":[["3a941c32.148ad4"]]},{"id":"578b4041.a5518","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1530,"y":460,"wires":[["a0a0e107.63b1c","a00252de.5f9dd"]]},{"id":"4078aabc.871734","type":"ui_chart","z":"ea614234.df4b8","name":"Accelerometer","group":"82a1ef24.b8612","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1980,"y":460,"wires":[[]]},{"id":"947240cd.42007","type":"ui_text","z":"ea614234.df4b8","group":"82a1ef24.b8612","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\"  ({{msg.payload.synchronizationStatus}})","layout":"col-center","x":1950,"y":340,"wires":[]},{"id":"fe861db1.2d429","type":"function","z":"ea614234.df4b8","name":"get_synchronizationStatus","func":"var synchronizationStatus = {}\nsynchronizationStatus.topic = \"synchronizationStatus\"\n// synchronization status is the first bit\nif(msg.payload&0x01 == 1){\n    synchronizationStatus.payload = \"synchronized\"\n}\nelse{\n    synchronizationStatus.payload = \"not synchronized\"\n}\nreturn synchronizationStatus;","outputs":1,"noerr":0,"x":800,"y":400,"wires":[["23c2b893.49de98"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"23c2b893.49de98","type":"join","z":"ea614234.df4b8","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":340,"wires":[["947240cd.42007"]]},{"id":"d32c4a1c.fdd6d8","type":"ui_chart","z":"ea614234.df4b8","name":"Inclinometer ","group":"82a1ef24.b8612","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1970,"y":540,"wires":[[]]},{"id":"e63e1fe.0c727e","type":"function","z":"ea614234.df4b8","name":"reset graph","func":"/* input */\nvar frameId = msg.payload\n// list of global variable name of old measurements of each sensor type (tilt, inclinometer)\nvar listOfBuffer = [\n    \"oldTiltMeasurements\",\n    \"oldInclMeasurements\"]\n\n// if frameId = to 0, it means it's a new streaming, so clear the graph by clearing old measurement\nif(frameId==0){\n    for(var i=0; i<listOfBuffer.length; i++){\n        flow.set(listOfBuffer[i], [])\n    }\n}\n","outputs":0,"noerr":0,"x":890,"y":660,"wires":[]},{"id":"84e242b3.d62da","type":"function","z":"ea614234.df4b8","name":"MQTT frame verification","func":"/*\nBecause the STREAMING topic is not reserved only for streaming mode data\n(shared with dynamic math result, SET and Shock detection),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x03 \nwhich is the code for the streaming mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's a streaming frame\nif(msg.payload[1]!=0x03){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":270,"y":500,"wires":[["b2ca74c0.20f0c8"]]},{"id":"245bc95e.900316","type":"comment","z":"ea614234.df4b8","name":"Read me","info":"Company: BeanAir\nDate:   31/03/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in streaming mode and display it in graph. \nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\n(Note: \n    + Data sample in 3 bytes, the last bit is a sign bit and all field are LSB first\n    + Time is in 6 bytes, 4 fr the reference time in unix format and the last 2 bytes for milliseconds)\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference docuement: \n    + http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n    \nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for dynamic measurement\n3- Start running the beandevice in Streaming mode\n\nSteps of this flow:\n1- connect to the broker\n2- subscribe to the topic \"STREAMING\" which is the topic for the dynamic measurement\n3- wait for payloads\n4- check DAC type if it's streaming\n5- parse the coming payload\n6- check if it's a new streaming (frame id = 0),if it is then clear the graph.(this will make the graph clean in streaming burst mode)\n6- display data in graph","x":80,"y":420,"wires":[]},{"id":"a574b82f.bda7e8","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/0)","topic":"F0B5D1A48F4E0000/SENSOR/0","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":380,"wires":[["134d2a15.d4f396"]]},{"id":"8b93cb85.d95b78","type":"function","z":"eaf85255.d8106","name":"parsing","func":"// Decalre variable for each object we need from the MQTT frame\nvar deviceType = {}\nvar dacType = {}\nvar channelId = {}\nvar time = {}\nvar data = {}\n\n/*******************************/\n/* Parsing the LDC frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// channel id\nchannelId.payload = msg.payload[2]\n\n// Reference time (in Unix format) (4 bytes) \ntime.payload = []\nfor(i=0; i<4; i++){\n    time.payload[i] = msg.payload[3+i]\n}\n\n// data in 3 bytes\ndata.payload = []\nfor(i=0; i<3; i++){\n    data.payload[i] = msg.payload[7+i]\n}\n\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, channelId, time, data]","outputs":5,"noerr":0,"x":640,"y":500,"wires":[["797cdaaf.bdffc4"],["f51cea0f.f1e7a8"],["9ef1fdf0.166dc"],["85e23b66.cb8b08"],["e86d16a4.4d8228"]]},{"id":"797cdaaf.bdffc4","type":"function","z":"eaf85255.d8106","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":880,"y":380,"wires":[["c6fc1247.08585"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"f51cea0f.f1e7a8","type":"function","z":"eaf85255.d8106","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"later\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":880,"y":440,"wires":[["c6fc1247.08585"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"85e23b66.cb8b08","type":"function","z":"eaf85255.d8106","name":"get-timestamp","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timestamp\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n\n\nreturn time_timeStamp;","outputs":1,"noerr":0,"x":880,"y":560,"wires":[["207c4320.3de5fc"]]},{"id":"207c4320.3de5fc","type":"join","z":"eaf85255.d8106","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":560,"wires":[["e5d813a.6f396f","683b459f.e2625c"]]},{"id":"e5d813a.6f396f","type":"function","z":"eaf85255.d8106","name":"to accelerometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nfilter = \"ch\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedAccelerometerMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    \n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1400,"y":520,"wires":[["23a5521b.e568fe"]]},{"id":"23a5521b.e568fe","type":"ui_chart","z":"eaf85255.d8106","name":"Accelerometer","group":"5e904f96.9d93d","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1620,"y":520,"wires":[[]]},{"id":"40e65d07.edb394","type":"ui_text","z":"eaf85255.d8106","group":"5e904f96.9d93d","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\" ","layout":"col-center","x":1590,"y":380,"wires":[]},{"id":"c6fc1247.08585","type":"join","z":"eaf85255.d8106","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":380,"wires":[["40e65d07.edb394"]]},{"id":"d16f5d66.0c632","type":"ui_chart","z":"eaf85255.d8106","name":"Inclinometer ","group":"5e904f96.9d93d","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1610,"y":600,"wires":[[]]},{"id":"134d2a15.d4f396","type":"function","z":"eaf85255.d8106","name":"MQTT frame verification","func":"/*\nBecause the Static topic is not reserved only for LowDutyCycle mode data\n(shared with ldc math result and alarm mode),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x01 \nwhich is the code for the LDC mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's from LDC mode\nif(msg.payload[1]!=0x01){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":430,"y":500,"wires":[["8b93cb85.d95b78"]]},{"id":"ac098eee.791c","type":"comment","z":"eaf85255.d8106","name":"Read me","info":"Company: BeanAir\nDate:  31/03/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in low duty cycle mode and display it in graph.\nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n    \nInformations we need:\n    LDCDA (Low Duty Cycle Data Acquisition) frame content:\n+(0)---------+(1)------+(2)--------+(3)------------+(7)---------+(10)\n|Device type |DAC type |Channel id |Reference time |Data sample |\n|(1 byte)    |(1 byte) |(1byte)    |(4 bytes)      |(3 bytes)   |\n+------------+---------+-----------+---------------+------------+\n\n(Note: \n    + Date time is in Unix format (LSB first)\n    + Data sample (LSB first), the last bit is a sign bit)\n    \nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference\ndocuement http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n\nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for static measurement of each channel\n3- Start running the beandevice in LDC mode\n\nSteps:\n1- connect to the broker\n2- subscribe to each sensor's static measurement topic\n3- wait for payloads\n4- check DAC type if it's LDC\n5- parse the coming payload\n6- display data in graph","x":80,"y":280,"wires":[]},{"id":"9ef1fdf0.166dc","type":"function","z":"eaf85255.d8106","name":"get_channelName","func":"var channelName = {}\nchannelName.topic = \"channelName\"\n\nswitch(msg.payload){\n    case 0x00:\n        channelName.payload = \"Ch_Z\"\n        break;\n    case 0x01:\n        channelName.payload = \"Ch_X\"\n        break;\n    case 0x02:\n        channelName.payload = \"Ch_Y\"\n        break;\n    case 0x03:\n        channelName.payload = \"Inc_X\"\n        break;\n    case 0x04:\n        channelName.payload = \"Inc_Y\"\n        break\n    default:\n        channelName.payload = \"Unknow\"\n        break;\n}\n\nreturn channelName;","outputs":1,"noerr":0,"x":890,"y":500,"wires":[["207c4320.3de5fc"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"e86d16a4.4d8228","type":"function","z":"eaf85255.d8106","name":"get_data","func":"// input\nvar dataHex = msg.payload\n// output\nvar data = {}\ndata.topic = \"data\"\n\n// measurement in 3 bytes , LSB first and last bit is a sign bit\n// convert hex to decimal\ndata.payload = 0x000000\ndata.payload |= dataHex[0]\ndata.payload |= (dataHex[1]<<8) \ndata.payload |= (dataHex[2]&0x7f<<16)\n\n//if sign bit equal 1 the measurement is negative\nif((dataHex[2]&0x80)==0x80){\n    data.payload *= -1\n}\n\n// divide data by 1000 to get the real measurement\ndata.payload = data.payload/1000\n\nreturn data;","outputs":1,"noerr":0,"x":860,"y":620,"wires":[["207c4320.3de5fc"]]},{"id":"464a9fba.9915","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/1)","topic":"F0B5D1A48F4E0000/SENSOR/1","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":440,"wires":[["134d2a15.d4f396"]]},{"id":"7e5b9df8.943994","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/2)","topic":"F0B5D1A48F4E0000/SENSOR/2","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":500,"wires":[["134d2a15.d4f396"]]},{"id":"b0741d11.19926","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/3)","topic":"F0B5D1A48F4E0000/SENSOR/3","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":560,"wires":[["134d2a15.d4f396"]]},{"id":"7e589961.70a4c8","type":"mqtt in","z":"eaf85255.d8106","name":"Broker (topic: SENSOR/4)","topic":"F0B5D1A48F4E0000/SENSOR/4","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":620,"wires":[["134d2a15.d4f396"]]},{"id":"683b459f.e2625c","type":"function","z":"eaf85255.d8106","name":"to inclinometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nfilter = \"inc\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedInclMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1390,"y":600,"wires":[["d16f5d66.0c632"]]},{"id":"5ae65c2d.8b7854","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/0)","topic":"F0B5D1A48F4E0000/SENSOR/0","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":380,"wires":[["3d3983b1.4304fc"]]},{"id":"9d1c7e48.9ffd1","type":"function","z":"53382208.28f12c","name":"parsing","func":"// Decalre variable for each object we need from the MQTT frame\nvar deviceType = {}\nvar dacType = {}\nvar channelId = {}\nvar time = {}\nvar alarmStatus = {}\nvar data = {}\n\n/*******************************/\n/* Parsing the Alarm frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// channel id\nchannelId.payload = msg.payload[2]\n\n// Reference time (in Unix format) (4 bytes) \ntime.payload = []\nfor(i=0; i<4; i++){\n    time.payload[i] = msg.payload[3+i]\n}\n\n// alarm status in 1 byte\nalarmStatus.payload = msg.payload[7]\n\n// data in 3 bytes\ndata.payload = []\nfor(i=0; i<3; i++){\n    data.payload[i] = msg.payload[8+i]\n}\n\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, alarmStatus, channelId, time, data]","outputs":6,"noerr":0,"x":640,"y":500,"wires":[["e221024b.d466e"],["a1b345bd.7a58e8"],["d689222b.93145"],["b2ca9722.713f18"],["1bc90eb1.9b0831"],["3ae27d2e.5898a2"]]},{"id":"e221024b.d466e","type":"function","z":"53382208.28f12c","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":880,"y":340,"wires":[["16cc8e6f.aced42"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"a1b345bd.7a58e8","type":"function","z":"53382208.28f12c","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"later\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":880,"y":400,"wires":[["16cc8e6f.aced42"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"1bc90eb1.9b0831","type":"function","z":"53382208.28f12c","name":"get-timestamp","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timestamp\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n\n\nreturn time_timeStamp;","outputs":1,"noerr":0,"x":880,"y":580,"wires":[["dfd6d4cb.79af18"]]},{"id":"dfd6d4cb.79af18","type":"join","z":"53382208.28f12c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1110,"y":640,"wires":[["fcb59871.578ac8","c8d7b689.7abde8"]]},{"id":"fcb59871.578ac8","type":"function","z":"53382208.28f12c","name":"to accelerometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because accelerometer sensors's name start with ch\nfilter = \"ch\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedAccelerometerMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    \n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1600,"y":600,"wires":[["c83a41d6.e9ff8"]]},{"id":"c83a41d6.e9ff8","type":"ui_chart","z":"53382208.28f12c","name":"Accelerometer","group":"af71a73e.e1d838","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1840,"y":600,"wires":[[]]},{"id":"e99703ba.47e9d","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":1,"width":25,"height":1,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\" ","layout":"col-center","x":1810,"y":340,"wires":[]},{"id":"16cc8e6f.aced42","type":"join","z":"53382208.28f12c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":340,"wires":[["e99703ba.47e9d"]]},{"id":"f3b56019.e96f6","type":"ui_chart","z":"53382208.28f12c","name":"Inclinometer ","group":"af71a73e.e1d838","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1830,"y":640,"wires":[[]]},{"id":"3d3983b1.4304fc","type":"function","z":"53382208.28f12c","name":"MQTT frame verification","func":"/*\nBecause the Static topic is not reserved only for Alarm mode data\n(shared with LDC mode and ldc math result),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x02 \nwhich is the code for the Alarm mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's from Alarm mode\nif(msg.payload[1]!=0x02){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":430,"y":500,"wires":[["9d1c7e48.9ffd1"]]},{"id":"1ee101a1.bc297e","type":"comment","z":"53382208.28f12c","name":"Read me","info":"Company: BeanAir\nDate:   01/04/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in Alarm mode and display it in graph along\nwith the alarm status for each channel.\nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\nInformations we need:\n    Alarm frame content:\n+(0)---------+(1)------+(2)--------+(3)------------+(7)----------+(8)---------+(11)\n|Device type |DAC type |Channel id |Reference time |Alarm status |Data sample |\n|(1 byte)    |(1 byte) |(1byte)    |(4 bytes)      |(1 byte)     |(3 bytes)   |\n+------------+---------+-----------+---------------+-------------+------------+\n\n(Note: \n    + Date time is in Unix format (LSB first)\n    + Alarm status are 4:\n        * 0x00 No Alarm\n        * 0x01 Alarm start\n        * 0x02 Alarm in progress\n        * 0x03 Alarm end\n    + Data sample (LSB first), the last bit is a sign bit and the rest is the absolute value multiplied by 1000 (to avoid using float number)\n      so don't forget the divide it by 1000 to get the correct measurment\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n    \nReference\ndocuement http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n\nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for static measurement of each channel\n3- Don't forget to set the threshold of each channel\n4- Start running the beandevice in Alarm mode\n\nSteps:\n1- connect to the broker\n2- subscribe to each sensor's topic (static measurment topics)\n3- wait for payloads\n4- check DAC type if it's Alarm\n5- parse the coming payload\n6- display data in graph\n7- display the Alarm status for each channel\n'''","x":80,"y":280,"wires":[]},{"id":"b2ca9722.713f18","type":"function","z":"53382208.28f12c","name":"get_channelName","func":"var channelName = {}\nchannelName.topic = \"channelName\"\n\nswitch(msg.payload){\n    case 0x00:\n        channelName.payload = \"Ch_Z\"\n        break;\n    case 0x01:\n        channelName.payload = \"Ch_X\"\n        break;\n    case 0x02:\n        channelName.payload = \"Ch_Y\"\n        break;\n    case 0x03:\n        channelName.payload = \"Inc_X\"\n        break;\n    case 0x04:\n        channelName.payload = \"Inc_Y\"\n        break\n    default:\n        channelName.payload = \"Unknow\"\n        break;\n}\n\nreturn channelName;","outputs":1,"noerr":0,"x":890,"y":520,"wires":[["dfd6d4cb.79af18","bc21e6c0.2640c8"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"3ae27d2e.5898a2","type":"function","z":"53382208.28f12c","name":"get_data","func":"// input\nvar dataHex = msg.payload\n// output\nvar data = {}\ndata.topic = \"data\"\n\n// measurement in 3 bytes , LSB first and last bit is a sign bit\n// convert hex to decimal\ndata.payload = 0x000000\ndata.payload |= dataHex[0]\ndata.payload |= (dataHex[1]<<8) \ndata.payload |= (dataHex[2]&0x7f<<16)\n\n//if sign bit equal 1 the measurement is negative\nif((dataHex[2]&0x80)==0x80){\n    data.payload *= -1\n}\n\n// divide data by 1000 to get the real measurement\ndata.payload = data.payload/1000\n\nreturn data;","outputs":1,"noerr":0,"x":860,"y":640,"wires":[["dfd6d4cb.79af18"]]},{"id":"5c991daa.06ce54","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/1)","topic":"F0B5D1A48F4E0000/SENSOR/1","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":440,"wires":[["3d3983b1.4304fc"]]},{"id":"b12195af.046a68","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/2)","topic":"F0B5D1A48F4E0000/SENSOR/2","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":500,"wires":[["3d3983b1.4304fc"]]},{"id":"eee50406.cd10d8","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/3)","topic":"F0B5D1A48F4E0000/SENSOR/3","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":560,"wires":[["3d3983b1.4304fc"]]},{"id":"62933e7b.4c6cd","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/4)","topic":"F0B5D1A48F4E0000/SENSOR/4","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":620,"wires":[["3d3983b1.4304fc"]]},{"id":"c8d7b689.7abde8","type":"function","z":"53382208.28f12c","name":"to inclinometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nfilter = \"inc\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedInclMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1590,"y":640,"wires":[["f3b56019.e96f6"]]},{"id":"d689222b.93145","type":"function","z":"53382208.28f12c","name":"get_AlarmStatus","func":"var alarmStatus = {}\nalarmStatus.topic = \"alarmStatus\"\nswitch(msg.payload){\n    case 0x00:\n        alarmStatus.payload = \"No Alarm\"\n        break\n    case 0x01:\n        alarmStatus.payload = \"Alarm start\"\n        break;\n    case 0x02:\n        alarmStatus.payload = \"Alarm in progress\"\n        break;\n    case 0x03:\n        alarmStatus.payload = \"Alarm end\"\n        break;\n    default:\n        alarmStatus.payload = \"Unknow\"\n        break;\n}\nreturn alarmStatus;","outputs":1,"noerr":0,"x":890,"y":460,"wires":[["bc21e6c0.2640c8"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"bc21e6c0.2640c8","type":"join","z":"53382208.28f12c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":460,"wires":[["16b3fdce.9a6812"]]},{"id":"90274bce.4f78d8","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":10,"width":4,"height":1,"name":"ch_z alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"col-center","x":1830,"y":380,"wires":[]},{"id":"16b3fdce.9a6812","type":"function","z":"53382208.28f12c","name":"update alarm status","func":"var storedChannelsAlarmStatus = flow.get(\"storedChannelsAlarmStatus\")\n\n// get list of channels from flow context variable of each sensor type\nvar channelName = msg.payload.channelName\nvar alarmStatus = msg.payload.alarmStatus\n\nvar channelExist = false\n\nif (typeof storedChannelsAlarmStatus == \"object\"){\n    for(var i=0; i<storedChannelsAlarmStatus.length; i++){\n        if(channelName==storedChannelsAlarmStatus[i].channelName){\n            channelExist = true\n            storedChannelsAlarmStatus[i].alarmStatus = alarmStatus\n        }\n    }\n}\nelse{\n    // if we didn't store measurement before, we need to decalare the global variable as an array\n    storedChannelsAlarmStatus = []\n}\nif(channelExist==false){\n    storedChannelsAlarmStatus.push({\"channelName\":channelName,\"alarmStatus\":alarmStatus})\n}\n\n\n//save measurements\nflow.set(\"storedChannelsAlarmStatus\", storedChannelsAlarmStatus)\nmsg.topic = \"listChannelAlarmStatus\"\nmsg.payload = storedChannelsAlarmStatus\nreturn msg;","outputs":1,"noerr":0,"x":1310,"y":460,"wires":[["71e374b9.68551c"]]},{"id":"46d49e64.8d1d2","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":11,"width":4,"height":1,"name":"ch_x alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"col-center","x":1830,"y":420,"wires":[]},{"id":"1c03383d.b6e8f8","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":12,"width":4,"height":1,"name":"ch_y alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"col-center","x":1830,"y":460,"wires":[]},{"id":"fe45b94f.1541b8","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":14,"width":4,"height":1,"name":"inc_x alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"row-spread","x":1830,"y":500,"wires":[]},{"id":"4fe9b9e9.767d08","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":16,"width":4,"height":1,"name":"inc_y alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"row-spread","x":1830,"y":540,"wires":[]},{"id":"71e374b9.68551c","type":"function","z":"53382208.28f12c","name":"Array to text","func":"// BeanDevice has 5 sensors at most\n// for each one return the alarm status\n// if one of them missing the alarm status, return null\n// the out put order will be: ch_z, ch_x, ch_y, inc_x, inc_y\n// format of each element: {\"channelName\":channelName,\"alarmStatus\":alarmStatus} (the same as the input)\ninputArray = msg.payload\n\nlistChannels = [\"ch_z\", \"ch_x\", \"ch_y\", \"inc_x\", \"inc_y\"]\noutputArray = [{\"payload\":\"\"}, {\"payload\":\"\"}, {\"payload\":\"\"}, {\"payload\":\"\"}, {\"payload\":\"\"}]\n\nfor(var i=0; i<listChannels.length; i++){\n    for(var j=0; j<inputArray.length; j++){\n        if(inputArray[j].channelName.toLowerCase().includes(listChannels[i])){\n            outputArray[i].payload ={\"channelName\":inputArray[j].channelName,\"alarmStatus\":inputArray[j].alarmStatus}\n        }\n    }\n}\n\nreturn outputArray;","outputs":5,"noerr":0,"x":1550,"y":460,"wires":[["90274bce.4f78d8"],["46d49e64.8d1d2"],["1c03383d.b6e8f8"],["fe45b94f.1541b8"],["4fe9b9e9.767d08"]]},{"id":"bdc0fe22.781c9","type":"mqtt in","z":"19e325ac.ee4faa","name":"Broker","topic":"F0B5D1A48F4E0000/STREAMING","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":70,"y":500,"wires":[["7e57ed51.196614"]]},{"id":"b9c1de8f.cd1ff","type":"function","z":"19e325ac.ee4faa","name":"parsing","func":"// Decalre variable for each object we need from the SSD frame\nvar deviceType = {}\nvar dacType = {}\nvar time = {}\nvar samplingRate = {}\nvar channelsBitmap = {}\nvar frameId = {}\nvar numberDacPerChannel = {}\nvar previousNumberDacPerChannel = {}\nvar syncronizationStatus = {}\nvar shockInfo = {}\nvar data = {}\ndata.topic = \"data\"\n\n// local variable\nvar i // for the for statement\nvar dataLen // for the total number of measurements\n\n/*******************************/\n/* Parsing the streaming frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// timestamp and milliseconds\n// The time in the streaming mode frame in 6 bytes.\n// 4 bytes for the Reference time in Unix format)\n// 2 byte for the Reference millisecond\ntime.payload = []\nfor(i=0; i<6; i++){\n    time.payload[i] = msg.payload[2+i]\n}\n// The sampling rate in 2 bytes\nsamplingRate.payload = []\nfor(i=0; i<2; i++){\n    samplingRate.payload[i] = msg.payload[8+i]\n}\n// The channels bitmap is in 4 bytes\nchannelsBitmap.payload = []\nfor(i=0; i<4; i++){\n    channelsBitmap.payload[i] = msg.payload[10+i]\n}\n// The frame Id in 3 byte\nframeId.payload = []\nfor(i=0; i<3; i++){\n    frameId.payload[i] = msg.payload[14+i]\n}\n// The current number of samples per channel in 2 bytes\nnumberDacPerChannel.payload = []\nfor(i=0; i<2; i++){\n    numberDacPerChannel.payload[i] = msg.payload[17+i]\n}\n// The previous number of samples per channel in 2 bytes\npreviousNumberDacPerChannel.payload = []\nfor(i=0; i<2; i++){\n    previousNumberDacPerChannel.payload[i] = msg.payload[25+i]\n}\n\n// the syncronization status\nsyncronizationStatus.payload = msg.payload[27]\n \n// shock informations in 7 bytes (1 byte for shock source, 2 bytes for data for each channel (X, Y and Z) )\nshockInfo.payload = []\nfor(i=0; i<7; i++){\n    shockInfo.payload[i] = msg.payload[29+i]\n}\n       \n// The data (or measurements) is the rest of the payload\n// frame length - the header length (fixed objects) or multiply the number of samples by the number of active channels\ndataLen = msg.payload.length - 36\ndata.payload = []\nfor(i=0; i<dataLen; i++){\n    data.payload[i] = msg.payload[36+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, syncronizationStatus, channelsBitmap, data, numberDacPerChannel, previousNumberDacPerChannel, frameId, time, samplingRate, shockInfo]","outputs":11,"noerr":0,"x":480,"y":500,"wires":[["d7af67a7.84dad8"],["a9009d8f.3326a"],["a5dc8a57.48d1c8"],["c845156e.0d5b58"],["e832dee8.0b135"],["a7aec0eb.a8f21"],["27a4a24b.c19a9e"],["777805ee.2c8edc"],["b84b45b2.65b038"],["a57efc44.d559c"],["d4f99a24.3c2e38"]]},{"id":"d7af67a7.84dad8","type":"function","z":"19e325ac.ee4faa","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":760,"y":280,"wires":[["3206635f.1f385c"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"a9009d8f.3326a","type":"function","z":"19e325ac.ee4faa","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":760,"y":340,"wires":[["3206635f.1f385c"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"c845156e.0d5b58","type":"function","z":"19e325ac.ee4faa","name":"get_channels","func":"/*\nthe channel bitmap is 4 bytes.\neach bit represent one channel status:\n    0 mean that channel is disable,\n    1 mean that channel enabel\nand from the bit index we can get the channel name\n*/\n\nvar channelsList=[]\nvar indexPos = 0;\nvar bitPos = 1\nvar i;\nfor(i=0; i<4; i++){\n    bitPos = 1\n    while(bitPos<=0x10){\n        if(msg.payload[i]&bitPos){\n            if(indexPos==0x00)\n                channelsList.push(\"Ch_Z\")\n            else if(indexPos==0x01)\n                channelsList.push(\"Ch_X\")\n            else if(indexPos==0x02)\n                channelsList.push(\"Ch_Y\")\n            else if(indexPos==0x03)\n                channelsList.push(\"Inc_X\")\n            else if(indexPos==0x04)\n                channelsList.push(\"Inc_Y\")\n        }\n        bitPos<<=1\n        indexPos+=1\n    }\n}\nmsg.payload = channelsList\nmsg.topic = \"channelsList\"\nreturn msg;","outputs":1,"noerr":0,"x":750,"y":460,"wires":[["e832dee8.0b135","6a644c7d.07f194"]]},{"id":"b84b45b2.65b038","type":"function","z":"19e325ac.ee4faa","name":"get-timestampAndMs","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timeStamp\"\nvar time_ms = {}\ntime_ms.topic = \"time_ms\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n// milliseconds\ntime_ms.payload = 0x0000\ntime_ms.payload |= msg.payload[4]\ntime_ms.payload |= msg.payload[5]<<8\n\nreturn [time_timeStamp, time_ms];","outputs":2,"noerr":0,"x":780,"y":780,"wires":[["f03bd673.d29288"],["f03bd673.d29288"]]},{"id":"71919003.ce605","type":"function","z":"19e325ac.ee4faa","name":"get_dateTimeArray","func":"// input\nvar time_timeStamp = msg.payload.time_timeStamp\nvar time_ms = msg.payload.time_ms\nvar samplingRate = msg.payload.samplingRate\nvar frameId = msg.payload.frameId\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar previouseNbrDataPerChannel = msg.payload.previouseNbrDataPerChannel\n// output\nvar dataTimeArray = {}\ndataTimeArray.topic = \"dataTimeArray\"\n\ndataTimeArray.payload = []\nvar subPacketRow = 0\nfor(subPacketRow=0; subPacketRow<currentNbrDataPerChannel;subPacketRow++){\n    var subPacketIndex = (frameId * previouseNbrDataPerChannel) + subPacketRow\n    dataTimeArray.payload.push(time_timeStamp+time_ms/1000+((1/samplingRate)*subPacketIndex))\n}\nreturn dataTimeArray;","outputs":1,"noerr":0,"x":1330,"y":720,"wires":[["6a644c7d.07f194"]]},{"id":"f03bd673.d29288","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"6","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":720,"wires":[["71919003.ce605"]]},{"id":"777805ee.2c8edc","type":"function","z":"19e325ac.ee4faa","name":"get_frameId","func":"//frame id in 3 bytes\nvar frameId = {}\nframeId.topic = \"frameId\"\n\nframeId.payload = 0x000000\nframeId.payload |= msg.payload[0]\nframeId.payload |= msg.payload[1]<<8\nframeId.payload |= msg.payload[2]<<16\n\nreturn frameId;","outputs":1,"noerr":0,"x":750,"y":720,"wires":[["f03bd673.d29288","91bc5c9.2b7d9a"]]},{"id":"a57efc44.d559c","type":"function","z":"19e325ac.ee4faa","name":"get_samplingRate","func":"//sampling rate in 2 bytes\nvar samplingRate = {}\nsamplingRate.topic = \"samplingRate\"\n\nsamplingRate.payload = 0x000000\nsamplingRate.payload |= msg.payload[0]\nsamplingRate.payload |= msg.payload[1]<<8\n\nreturn samplingRate;","outputs":1,"noerr":0,"x":770,"y":840,"wires":[["f03bd673.d29288"]]},{"id":"a7aec0eb.a8f21","type":"function","z":"19e325ac.ee4faa","name":"get_currentNbrDataPerChannel","func":"//current number of data per channel in 2 bytes\nvar currentNbrDataPerChannel = {}\ncurrentNbrDataPerChannel.topic = \"currentNbrDataPerChannel\"\n\ncurrentNbrDataPerChannel.payload = 0x000000\ncurrentNbrDataPerChannel.payload |= msg.payload[0]\ncurrentNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn currentNbrDataPerChannel;","outputs":1,"noerr":0,"x":810,"y":540,"wires":[["f03bd673.d29288","e832dee8.0b135"]]},{"id":"27a4a24b.c19a9e","type":"function","z":"19e325ac.ee4faa","name":"get_previouseNbrDataPerChannel","func":"//previouse number of data per channel in 2 bytes\nvar previouseNbrDataPerChannel = {}\npreviouseNbrDataPerChannel.topic = \"previouseNbrDataPerChannel\"\n\npreviouseNbrDataPerChannel.payload = 0x000000\npreviouseNbrDataPerChannel.payload |= msg.payload[0]\npreviouseNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn previouseNbrDataPerChannel;","outputs":1,"noerr":0,"x":820,"y":600,"wires":[["f03bd673.d29288"]]},{"id":"bc6f9279.0ef21","type":"function","z":"19e325ac.ee4faa","name":"get_dataArray","func":"// input\nvar data = msg.payload.data\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar nbrChannels = (msg.payload.channelsList).length\n// output\nvar dataArray = {}\ndataArray.topic = \"dataArray\"\n/* out put struction */\n/*\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 0 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 1 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n.\n.\n.\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel m | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n\n2 dimensional array\nfirst dimension for channels\nsecond dimension for data of each channel\n\n*/\n// indexs\nvar i=0 // for the number of channels\nvar j=0 // for the current number of data per channel\nvar pos=0 // to keep track of the index of data\n\ndataArray.payload = new Array(nbrChannels)\nfor(i=0; i<nbrChannels; i++){\n    dataArray.payload[i] = new Array(currentNbrDataPerChannel)\n    for(j=0; j<currentNbrDataPerChannel; j++){\n        pos = i*3+j*nbrChannels*3\n        // sample in 3 bytes (signed and LSB)\n        dataArray.payload[i][j] = 0x000000\n        dataArray.payload[i][j] |= data[pos]\n        dataArray.payload[i][j] |= (data[pos+1]<<8) \n        dataArray.payload[i][j] |= (data[pos+2]&0x7f<<16)\n        dataArray.payload[i][j] = dataArray.payload[i][j]/1000\n        //if sign bit equal 1 the measurement is negative\n        if((data[pos+2]&0x80)==0x80){\n            dataArray.payload[i][j] *= -1\n        }\n    }\n}\n\nreturn dataArray;","outputs":1,"noerr":0,"x":1320,"y":500,"wires":[["6a644c7d.07f194"]]},{"id":"e832dee8.0b135","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":500,"wires":[["bc6f9279.0ef21"]]},{"id":"6a644c7d.07f194","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1530,"y":460,"wires":[["bce018ab.9e6dd8","64883632.96dbf8"]]},{"id":"e52fa54b.4c30b8","type":"ui_chart","z":"19e325ac.ee4faa","name":"Accelerometer","group":"ef1869fd.367b78","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1980,"y":460,"wires":[[]]},{"id":"38f238d7.cf3bb8","type":"ui_text","z":"19e325ac.ee4faa","group":"ef1869fd.367b78","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\"  ({{msg.payload.synchronizationStatus}})","layout":"col-center","x":1950,"y":340,"wires":[]},{"id":"a5dc8a57.48d1c8","type":"function","z":"19e325ac.ee4faa","name":"get_synchronizationStatus","func":"var synchronizationStatus = {}\nsynchronizationStatus.topic = \"synchronizationStatus\"\n// synchronization status is the first bit\nif(msg.payload&0x01 == 1){\n    synchronizationStatus.payload = \"synchronized\"\n}\nelse{\n    synchronizationStatus.payload = \"not synchronized\"\n}\nreturn synchronizationStatus;","outputs":1,"noerr":0,"x":800,"y":400,"wires":[["3206635f.1f385c"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"3206635f.1f385c","type":"join","z":"19e325ac.ee4faa","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":340,"wires":[["38f238d7.cf3bb8"]]},{"id":"df079c91.db755","type":"ui_chart","z":"19e325ac.ee4faa","name":"Inclinometer ","group":"ef1869fd.367b78","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1970,"y":540,"wires":[[]]},{"id":"91bc5c9.2b7d9a","type":"function","z":"19e325ac.ee4faa","name":"reset graph","func":"/* input */\nvar frameId = msg.payload\n// list of global variable name of old measurements of each sensor type (tilt, inclinometer)\nvar listOfBuffer = [\n    \"oldTiltMeasurements\",\n    \"oldInclMeasurements\"]\n\n// if frameId = to 0, it means it's a new streaming, so clear the graph by clearing old measurement\nif(frameId==0){\n    for(var i=0; i<listOfBuffer.length; i++){\n        flow.set(listOfBuffer[i], [])\n    }\n}\n","outputs":0,"noerr":0,"x":890,"y":660,"wires":[]},{"id":"7e57ed51.196614","type":"function","z":"19e325ac.ee4faa","name":"MQTT frame verification","func":"/*\nBecause the STREAMING topic is not reserved only for SSD mode data\n(shared with dynamic math result, SET and Streaming),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x03 \nwhich is the code for the SSD mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's a SSD frame\nif(msg.payload[1]!=0x04){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":270,"y":500,"wires":[["b9c1de8f.cd1ff"]]},{"id":"cffd7571.92cf28","type":"comment","z":"19e325ac.ee4faa","name":"Read me","info":"Company: BeanAir\nDate:   02/04/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in SSD mode and display it in graph. \nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\n(Note: \n    + Data sample in 3 bytes, the last bit is a sign bit and all field are LSB first\n    + X, Y and Z first data (2 bytes) uses the 2's compelement format\n    + Time is in 6 bytes, 4 fr the reference time in unix format and the last 2 bytes for milliseconds)\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference docuement: \n    + http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n    \nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for dynamic measurement\n3- Start running the beandevice in Shock Detection mode\n\nSteps of this flow:\n1- connect to the broker\n2- subscribe to the topic \"STREAMING\" which is the topic for the dynamic measurement\n3- wait for payloads\n4- check DAC type if it's Shock detection\n5- parse the coming payload\n6- check if it's a new streaming (frame id = 0),if it is then clear the graph.\n6- display data in graph","x":80,"y":420,"wires":[]},{"id":"d4f99a24.3c2e38","type":"function","z":"19e325ac.ee4faa","name":"get_shock dection informations","func":"//shock detection in 7 bytes\n// first byte for shock source (X, Y or Z)\n// the value of each sensor in 2 bytes (uses the 2's compelement format)\nvar shockSource = msg.payload[0]\n\nif(shockSource==0x00)\n    shockSource = \"Z axis\"\nelse if(shockSource==0x01)\n    shockSource = \"X axis\"\nelse if(shockSource==0x02)\n    shockSource = \"Y axis\"\n\n// get value and use 2's complement to convert them to decimal\n// because the bitwise operation 'NOT' will effect the 32 bits (other machine 64 bits depends on decimal size) and not the 2 bytes\n// we need to keep only the first 2 bytes\n// which require to use of the bitmask. (0xff) \n\nvar x_value = 0\nx_value += msg.payload[1]\nx_value += msg.payload[2] << 8\nif(x_value>0x8000){\n    x_value = ~x_value\n    x_value = x_value >>> 0\n    x_value &= 0xffff\n    x_value += 1\n    y_value *= -1\n}\nx_value = x_value/1000\n\nvar y_value = 0\ny_value += msg.payload[3]\ny_value += msg.payload[4] << 8\nif(y_value>0x8000){\n    y_value = ((~y_value>>>0) & 0x0000ffff)+1\n    y_value *= -1\n}\ny_value = y_value/1000\n\nvar z_value = 0\nz_value += msg.payload[5]\nz_value += msg.payload[6] << 8\nif(z_value>0x8000){\n   z_value = ((~z_value>>>0) & 0xffff)+1\n   z_value *= -1\n}\nz_value = z_value/1000\n\n\nmsg.payload = {}\nmsg.payload.source = shockSource\nmsg.payload.x = x_value\nmsg.payload.y = y_value\nmsg.payload.z = z_value\n\nreturn msg;","outputs":1,"noerr":0,"x":810,"y":900,"wires":[["a342529f.a3dc4"]]},{"id":"a342529f.a3dc4","type":"ui_text","z":"19e325ac.ee4faa","group":"ef1869fd.367b78","order":10,"width":0,"height":0,"name":"","label":"","format":"Shock source: {{msg.payload.source}} \"X axis: {{msg.payload.x}} ; Y axis: {{msg.payload.y}} ; Z axis: {{msg.payload.z}}\"","layout":"col-center","x":1950,"y":900,"wires":[]},{"id":"ada18937.329118","type":"mqtt in","z":"7fdfc2f.0fa413c","name":"Broker","topic":"F0B5D1A48F4E0000/STREAMING","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":70,"y":500,"wires":[["844f2feb.ce922"]]},{"id":"8287f357.a1695","type":"function","z":"7fdfc2f.0fa413c","name":"parsing","func":"// Decalre variable for each object we need from the SET frame\nvar deviceType = {}\nvar dacType = {}\nvar time = {}\nvar samplingRate = {}\nvar channelsBitmap = {}\nvar frameId = {}\nvar numberDacPerChannel = {}\nvar previousNumberDacPerChannel = {}\nvar syncronizationStatus = {}\nvar alarmStatus = {}\nvar data = {}\ndata.topic = \"data\"\n\n// local variable\nvar i // for the for statement\nvar dataLen // for the total number of measurements\n\n/*******************************/\n/* Parsing the SET frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// timestamp and milliseconds\n// The time in the SET mode frame in 6 bytes.\n// 4 bytes for the Reference time in Unix format)\n// 2 byte for the Reference millisecond\ntime.payload = {}\nfor(i=0; i<6; i++){\n    time.payload[i] = msg.payload[2+i]\n}\n// The sampling rate in 2 bytes\nsamplingRate.payload = {}\nfor(i=0; i<2; i++){\n    samplingRate.payload[i] = msg.payload[8+i]\n}\n// The channels bitmap is in 4 bytes\nchannelsBitmap.payload = {}\nfor(i=0; i<4; i++){\n    channelsBitmap.payload[i] = msg.payload[10+i]\n}\n// The frame Id in 3 byte\nframeId.payload = {}\nfor(i=0; i<3; i++){\n    frameId.payload[i] = msg.payload[14+i]\n}\n// The current number of samples per channel in 2 bytes\nnumberDacPerChannel.payload = {}\nfor(i=0; i<2; i++){\n    numberDacPerChannel.payload[i] = msg.payload[17+i]\n}\n// The previous number of samples per channel in 2 bytes\npreviousNumberDacPerChannel.payload = {}\nfor(i=0; i<2; i++){\n    previousNumberDacPerChannel.payload[i] = msg.payload[25+i]\n}\n\n// the syncronization status\nsyncronizationStatus.payload = msg.payload[27]\n\n// the Alarm status (we will not use it because it has no information, always 0)\nalarmStatus.payload = msg.payload[29] \n       \n// The data (or measurements) is the rest of the payload\n// frame length - the header length (fixed objects) or multiply the number of samples by the number of active channels\ndataLen = msg.payload.length - 30\ndata.payload = []\nfor(i=0; i<dataLen; i++){\n    data.payload[i] = msg.payload[30+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, syncronizationStatus, channelsBitmap, data, numberDacPerChannel, previousNumberDacPerChannel, frameId, time, samplingRate, alarmStatus]","outputs":11,"noerr":0,"x":480,"y":500,"wires":[["40d946e0.bd7cc8"],["d37a0222.76332"],["32558d7f.dc5eb2"],["ec3ff6ff.4db7c8"],["2d372b00.030b16"],["e5e017f4.1d8828"],["4fd9a5e3.2473bc"],["44e267dc.899868"],["dabce9cc.174828"],["5b03cbeb.e80754"],[]]},{"id":"40d946e0.bd7cc8","type":"function","z":"7fdfc2f.0fa413c","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":760,"y":280,"wires":[["afc45210.7cb56"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"d37a0222.76332","type":"function","z":"7fdfc2f.0fa413c","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":760,"y":340,"wires":[["afc45210.7cb56"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"ec3ff6ff.4db7c8","type":"function","z":"7fdfc2f.0fa413c","name":"get_channels","func":"/*\nthe channel bitmap is 4 bytes.\neach bit represent one channel status:\n    0 mean that channel is disable,\n    1 mean that channel enabel\nand from the bit index we can get the channel name\n*/\n\nvar channelsList=[]\nvar indexPos = 0;\nvar bitPos = 1\nvar i;\nfor(i=0; i<4; i++){\n    bitPos = 1\n    while(bitPos<=0x10){\n        if(msg.payload[i]&bitPos){\n            if(indexPos==0x00)\n                channelsList.push(\"Ch_Z\")\n            else if(indexPos==0x01)\n                channelsList.push(\"Ch_X\")\n            else if(indexPos==0x02)\n                channelsList.push(\"Ch_Y\")\n            else if(indexPos==0x03)\n                channelsList.push(\"Inc_X\")\n            else if(indexPos==0x04)\n                channelsList.push(\"Inc_Y\")\n        }\n        bitPos<<=1\n        indexPos+=1\n    }\n}\nmsg.payload = channelsList\nmsg.topic = \"channelsList\"\nreturn msg;","outputs":1,"noerr":0,"x":750,"y":460,"wires":[["2d372b00.030b16","afebbf3f.a4294"]]},{"id":"dabce9cc.174828","type":"function","z":"7fdfc2f.0fa413c","name":"get-timestampAndMs","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timeStamp\"\nvar time_ms = {}\ntime_ms.topic = \"time_ms\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n// milliseconds\ntime_ms.payload = 0x0000\ntime_ms.payload |= msg.payload[4]\ntime_ms.payload |= msg.payload[5]<<8\n\nreturn [time_timeStamp, time_ms];","outputs":2,"noerr":0,"x":780,"y":780,"wires":[["ea407ee7.8915d"],["ea407ee7.8915d"]]},{"id":"434570ec.49a3e","type":"function","z":"7fdfc2f.0fa413c","name":"get_dateTimeArray","func":"// input\nvar time_timeStamp = msg.payload.time_timeStamp\nvar time_ms = msg.payload.time_ms\nvar samplingRate = msg.payload.samplingRate\nvar frameId = msg.payload.frameId\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar previouseNbrDataPerChannel = msg.payload.previouseNbrDataPerChannel\n// output\nvar dataTimeArray = {}\ndataTimeArray.topic = \"dataTimeArray\"\n\ndataTimeArray.payload = []\nvar subPacketRow = 0\nfor(subPacketRow=0; subPacketRow<currentNbrDataPerChannel;subPacketRow++){\n    var subPacketIndex = (frameId * previouseNbrDataPerChannel) + subPacketRow\n    dataTimeArray.payload.push(time_timeStamp+time_ms/1000+((1/samplingRate)*subPacketIndex))\n}\nreturn dataTimeArray;","outputs":1,"noerr":0,"x":1330,"y":720,"wires":[["afebbf3f.a4294"]]},{"id":"ea407ee7.8915d","type":"join","z":"7fdfc2f.0fa413c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"6","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":720,"wires":[["434570ec.49a3e"]]},{"id":"44e267dc.899868","type":"function","z":"7fdfc2f.0fa413c","name":"get_frameId","func":"//frame id in 3 bytes\nvar frameId = {}\nframeId.topic = \"frameId\"\n\nframeId.payload = 0x000000\nframeId.payload |= msg.payload[0]\nframeId.payload |= msg.payload[1]<<8\nframeId.payload |= msg.payload[2]<<16\n\nreturn frameId;","outputs":1,"noerr":0,"x":750,"y":720,"wires":[["ea407ee7.8915d","f6a079bc.4da378"]]},{"id":"5b03cbeb.e80754","type":"function","z":"7fdfc2f.0fa413c","name":"get_samplingRate","func":"//sampling rate in 2 bytes\nvar samplingRate = {}\nsamplingRate.topic = \"samplingRate\"\n\nsamplingRate.payload = 0x000000\nsamplingRate.payload |= msg.payload[0]\nsamplingRate.payload |= msg.payload[1]<<8\n\nreturn samplingRate;","outputs":1,"noerr":0,"x":770,"y":840,"wires":[["ea407ee7.8915d"]]},{"id":"e5e017f4.1d8828","type":"function","z":"7fdfc2f.0fa413c","name":"get_currentNbrDataPerChannel","func":"//current number of data per channel in 2 bytes\nvar currentNbrDataPerChannel = {}\ncurrentNbrDataPerChannel.topic = \"currentNbrDataPerChannel\"\n\ncurrentNbrDataPerChannel.payload = 0x000000\ncurrentNbrDataPerChannel.payload |= msg.payload[0]\ncurrentNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn currentNbrDataPerChannel;","outputs":1,"noerr":0,"x":810,"y":540,"wires":[["ea407ee7.8915d","2d372b00.030b16"]]},{"id":"4fd9a5e3.2473bc","type":"function","z":"7fdfc2f.0fa413c","name":"get_previouseNbrDataPerChannel","func":"//previouse number of data per channel in 2 bytes\nvar previouseNbrDataPerChannel = {}\npreviouseNbrDataPerChannel.topic = \"previouseNbrDataPerChannel\"\n\npreviouseNbrDataPerChannel.payload = 0x000000\npreviouseNbrDataPerChannel.payload |= msg.payload[0]\npreviouseNbrDataPerChannel.payload |= msg.payload[1]<<8\n\nreturn previouseNbrDataPerChannel;","outputs":1,"noerr":0,"x":820,"y":600,"wires":[["ea407ee7.8915d"]]},{"id":"1d76876f.814a59","type":"function","z":"7fdfc2f.0fa413c","name":"get_dataArray","func":"// input\nvar data = msg.payload.data\nvar currentNbrDataPerChannel = msg.payload.currentNbrDataPerChannel\nvar nbrChannels = (msg.payload.channelsList).length\n// output\nvar dataArray = {}\ndataArray.topic = \"dataArray\"\n/* out put struction */\n/*\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 0 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel 1 | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n.\n.\n.\n+-----------+-----------------------------------+\n|           | +-------+--------+-----+--------+ |\n| channel m | |data 0 | data 1 | ... | data n | |\n|           | +-------+--------+-----+--------+ |\n+-----------+-----------------------------------+\n\n2 dimensional array\nfirst dimension for channels\nsecond dimension for data of each channel\n\n*/\n// indexs\nvar i=0 // for the number of channels\nvar j=0 // for the current number of data per channel\nvar pos=0 // to keep track of the index of data\n\ndataArray.payload = new Array(nbrChannels)\nfor(i=0; i<nbrChannels; i++){\n    dataArray.payload[i] = new Array(currentNbrDataPerChannel)\n    for(j=0; j<currentNbrDataPerChannel; j++){\n        pos = i*3+j*nbrChannels*3\n        // sample in 3 bytes (signed and LSB)\n        dataArray.payload[i][j] = 0x000000\n        dataArray.payload[i][j] |= data[pos]\n        dataArray.payload[i][j] |= (data[pos+1]<<8) \n        dataArray.payload[i][j] |= (data[pos+2]&0x7f<<16)\n        dataArray.payload[i][j] = dataArray.payload[i][j]/1000\n        //if sign bit equal 1 the measurement is negative\n        if((data[pos+2]&0x80)==0x80){\n            dataArray.payload[i][j] *= -1\n        }\n    }\n}\n\nreturn dataArray;","outputs":1,"noerr":0,"x":1320,"y":500,"wires":[["afebbf3f.a4294"]]},{"id":"2d372b00.030b16","type":"join","z":"7fdfc2f.0fa413c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":500,"wires":[["1d76876f.814a59"]]},{"id":"afebbf3f.a4294","type":"join","z":"7fdfc2f.0fa413c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1530,"y":460,"wires":[["cd2b0952.562708","596a3240.830e7c"]]},{"id":"a4576aab.eab278","type":"ui_chart","z":"7fdfc2f.0fa413c","name":"Accelerometer","group":"b2661d4d.1e592","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1980,"y":460,"wires":[[]]},{"id":"9587b053.75c2c","type":"ui_text","z":"7fdfc2f.0fa413c","group":"b2661d4d.1e592","order":1,"width":0,"height":0,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\"  ({{msg.payload.synchronizationStatus}})","layout":"col-center","x":1950,"y":340,"wires":[]},{"id":"32558d7f.dc5eb2","type":"function","z":"7fdfc2f.0fa413c","name":"get_synchronizationStatus","func":"var synchronizationStatus = {}\nsynchronizationStatus.topic = \"synchronizationStatus\"\n// synchronization status is the first bit\nif(msg.payload&0x01 == 1){\n    synchronizationStatus.payload = \"synchronized\"\n}\nelse{\n    synchronizationStatus.payload = \"not synchronized\"\n}\nreturn synchronizationStatus;","outputs":1,"noerr":0,"x":800,"y":400,"wires":[["afc45210.7cb56"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"afc45210.7cb56","type":"join","z":"7fdfc2f.0fa413c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1150,"y":340,"wires":[["9587b053.75c2c"]]},{"id":"87461e36.27d95","type":"ui_chart","z":"7fdfc2f.0fa413c","name":"Inclinometer ","group":"b2661d4d.1e592","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss SSS DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1970,"y":540,"wires":[[]]},{"id":"f6a079bc.4da378","type":"function","z":"7fdfc2f.0fa413c","name":"reset graph","func":"/* input */\nvar frameId = msg.payload\n// list of global variable name of old measurements of each sensor type (tilt, inclinometer)\nvar listOfBuffer = [\n    \"oldTiltMeasurements\",\n    \"oldInclMeasurements\"]\n\n// if frameId = to 0, it means it's a new streaming, so clear the graph by clearing old measurement\nif(frameId==0){\n    for(var i=0; i<listOfBuffer.length; i++){\n        flow.set(listOfBuffer[i], [])\n    }\n}","outputs":0,"noerr":0,"x":890,"y":660,"wires":[]},{"id":"844f2feb.ce922","type":"function","z":"7fdfc2f.0fa413c","name":"MQTT frame verification","func":"/*\nBecause the STREAMING topic is not reserved only for SET mode data\n(shared with dynamic math result, SET and Shock detection),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x03 \nwhich is the code for the SET mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's a SET frame\nif(msg.payload[1]!=0x06){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":270,"y":500,"wires":[["8287f357.a1695"]]},{"id":"905c5bc5.d60d28","type":"comment","z":"7fdfc2f.0fa413c","name":"Read me","info":"Company: BeanAir\nDate:   02/04/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in SET mode and display it in graph. \nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\n(Note: \n    + Data sample in 3 bytes, the last bit is a sign bit and all field are LSB first\n    + Time is in 6 bytes, 4 fr the reference time in unix format and the last 2 bytes for milliseconds)\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n\nReference docuement: \n    + http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n    \nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for dynamic measurement\n3- Start running the beandevice in SET mode\n\nSteps of this flow:\n1- connect to the broker\n2- subscribe to the topic \"STREAMING\" which is the topic for the dynamic measurement\n3- wait for payloads\n4- check DAC type if it's SET\n5- parse the coming payload\n6- check if it's a new streaming (frame id = 0),if it is then clear the graph.\n6- display data in graph","x":80,"y":420,"wires":[]},{"id":"cd2b0952.562708","type":"function","z":"7fdfc2f.0fa413c","name":"to accelerometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nvar filter = \"ch\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldAccelerometerMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1740,"y":460,"wires":[["a4576aab.eab278"]]},{"id":"596a3240.830e7c","type":"function","z":"7fdfc2f.0fa413c","name":"to inclinometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nvar filter = \"inc\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldInclMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1750,"y":540,"wires":[["87461e36.27d95"]]},{"id":"a0a0e107.63b1c","type":"function","z":"ea614234.df4b8","name":"to accelerometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nvar filter = \"ch\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldAccelerometerMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1740,"y":460,"wires":[["4078aabc.871734"]]},{"id":"a00252de.5f9dd","type":"function","z":"ea614234.df4b8","name":"to inclinometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nvar filter = \"inc\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldInclMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1750,"y":540,"wires":[["d32c4a1c.fdd6d8"]]},{"id":"bce018ab.9e6dd8","type":"function","z":"19e325ac.ee4faa","name":"to accelerometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because Accelerometer sensors's name start with ch\nvar filter = \"ch\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldAccelerometerMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1740,"y":460,"wires":[["e52fa54b.4c30b8"]]},{"id":"64883632.96dbf8","type":"function","z":"19e325ac.ee4faa","name":"to inclinometer dashboard","func":"/* input */\nvar channels = msg.payload.channelsList\nvar data = msg.payload.dataArray\nvar timestamp = msg.payload.dataTimeArray\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nvar filter = \"inc\"\n// the variable label of the old measurement in the context\nvar oldMeasurementBuffer_variableName = \"oldInclMeasurements\"\n// maximum number to get from the old measurement\nvar graphMaxSize = 2000\n/* saved data */\nvar oldMeasurements = flow.get(oldMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// use object to hold the json data to send to graph\ndataObject = {}\n\n// graph labels. (no need to use any label)\ndataObject.labels=[]\n\n// graph series (fill it later)\ndataObject.series = []\n\n// graph data (measurement)\ndataObject.data = []\nvar newMeasurments = true\n//   check if there old data stored before\nif (typeof oldMeasurements == \"object\"){\n    if(oldMeasurements.hasOwnProperty(\"data\")){\n        newMeasurments = false\n    }\n}\n// old measurement memory contains only the data from filtered channel, so its length will be less then the channels and data from input\n// this is why we need double iterators, i for the stored data and it will increase each time a channel pass the filter and index is for the upcoming data\nvar i = 0\nfor(var index in channels){\n    // get channel by filter\n    if(channels[index].toLowerCase().includes(filter)){\n        // add channel name to list of series\n        dataObject.series.push(channels[index])\n        // add measurement to the data list\n        var dataBuffer = []\n        // if it's not a new stream, get the last [graphMaxSize] measurements\n        if(newMeasurments === false){\n            var stop=oldMeasurements.data[i].length\n            var start=0\n            if(stop>graphMaxSize){\n                start = stop-graphMaxSize\n            }\n            for(; start<stop; start++){\n                dataBuffer.push(oldMeasurements.data[i][start])\n            }\n        }\n        // add the new measurements with the corresponding time\n        for(var j in timestamp){\n            var element = {}\n            element.y = data[index][j]\n            element.x = Math.trunc(timestamp[j]*1000)\n            dataBuffer.push(element)\n        }\n        dataObject.data.push(dataBuffer)\n        i++\n    }\n}\ndashboardData.payload.push(dataObject)\n//save measurements\nflow.set(oldMeasurementBuffer_variableName, dataObject)\nreturn dashboardData;","outputs":1,"noerr":0,"x":1750,"y":540,"wires":[["df079c91.db755"]]},{"id":"472d8a06.285f84","type":"mqtt in","z":"d133d0a9.0850c","name":"Broker (topic: SENSOR/0)","topic":"F0B5D1A48F4E0000/SENSOR/0","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":550,"y":420,"wires":[["68db4e4b.95b99"]]},{"id":"38b30bfc.a74154","type":"comment","z":"d133d0a9.0850c","name":"Read me","info":"Company: BeanAir\nDate:   03/04/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to receive, parse and display the LDC math result.\nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n\n\nInformations we need:\n    LDC (Low Duty Cycle) Math Result frame content:\n+(0)---------+(1)------+(2)--------+(3)------------+(4)--------+(8)--------+(12)------+(16)--------+(19)\n|Device type |DAC type |Channel id |Math result Id |Event time |Start time |End time  |Data sample |\n|(1 byte)    |(1 byte) |(1byte)    |(1 byte)       |(4 bytes)  |(4 bytes)  |(4 bytes) |(3 bytes)   |\n+------------+---------+-----------+---------------+-----------+-----------+----------+------------+\n\n(Note: \n    + Time (Event, Start and End) is in Unix format (LSB first)\n    + Data sample (LSB first), the last bit is a sign bit)\n    + The Event time is for the maximum and minimum math result only\n    + The Start and End time is for the average math result only\n    \nReference\ndocuement http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n\nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for static measurement of each channel\n3- Start running the beandevice in LDC mode\n\nSteps:\n1- connect to the broker\n2- subscribe to Ldc math result topics which is the list of static measurement topics in the beanscape MQTT configuration of the beandevice {[MAC_ID]/Sensor0, [MAC_ID]/Sensor1 ... etc}\n3- wait for payloads\n4- check DAC type if it's LDC Math Result\n5- parse the coming payload\n6- print the information","x":500,"y":320,"wires":[]},{"id":"a79a1021.58a7c","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":7,"width":8,"height":1,"name":"Z Average value","label":"Average value :","format":"{{msg.payload.avgValue}}","layout":"row-center","x":1140,"y":380,"wires":[]},{"id":"bf6e06ca.440fc8","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":8,"width":4,"height":1,"name":"z start time","label":"Start time:","format":"{{msg.payload.startTime}}","layout":"row-center","x":1130,"y":500,"wires":[]},{"id":"abea9a78.b75f78","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":1,"width":4,"height":1,"name":"Z Maximum Measurment","label":"Maximum Measurment:","format":"{{msg.payload.maxValue}}","layout":"row-center","x":1170,"y":300,"wires":[]},{"id":"7632e8c5.f6c948","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":9,"width":4,"height":1,"name":"z end time","label":"End time:","format":"{{msg.payload.endTime}}","layout":"row-center","x":1130,"y":540,"wires":[]},{"id":"6c91c963.271888","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":2,"width":4,"height":1,"name":"z max event time","label":"Event time:","format":"{{msg.payload.maxEventTime}}","layout":"row-center","x":1150,"y":420,"wires":[]},{"id":"cb5705a4.1cfb88","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":4,"width":4,"height":1,"name":"Z Minimum Measurmen","label":"Minimum Measurment:","format":"{{msg.payload.minValue}}","layout":"row-center","x":1170,"y":340,"wires":[]},{"id":"59e307fc.f14ec8","type":"ui_text","z":"d133d0a9.0850c","group":"f6818abe.1b0bd8","order":5,"width":4,"height":1,"name":"z min event time","label":"Event time:","format":"{{msg.payload.minEventTime}}","layout":"row-center","x":1140,"y":460,"wires":[]},{"id":"12c8c135.e9da5f","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":1,"width":4,"height":1,"name":"X Maximum Measurment","label":"Maximum Measurment:","format":"{{msg.payload.maxValue}}","layout":"row-center","x":1170,"y":620,"wires":[]},{"id":"7b0634a9.26d59c","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":2,"width":4,"height":1,"name":"X max event time","label":"Event time:","format":"{{msg.payload.maxEventTime}}","layout":"row-center","x":1150,"y":740,"wires":[]},{"id":"7c451476.3dd39c","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":4,"width":4,"height":1,"name":"X Minimum Measurmen","label":"Minimum Measurment:","format":"{{msg.payload.minValue}}","layout":"row-center","x":1170,"y":660,"wires":[]},{"id":"5973f8bd.0843b8","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":5,"width":4,"height":1,"name":"x min event time","label":"Event time:","format":"{{msg.payload.minEventTime}}","layout":"row-center","x":1140,"y":780,"wires":[]},{"id":"d39747ed.6fdc08","type":"mqtt in","z":"d133d0a9.0850c","name":"Broker (topic: SENSOR/1)","topic":"F0B5D1A48F4E0000/SENSOR/1","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":550,"y":740,"wires":[["389373d2.b42c9c"]]},{"id":"338ef573.a08fca","type":"mqtt in","z":"d133d0a9.0850c","name":"Broker (topic: SENSOR/2)","topic":"F0B5D1A48F4E0000/SENSOR/2","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":550,"y":1060,"wires":[["a534b993.0ad078"]]},{"id":"6c270d19.1177f4","type":"mqtt in","z":"d133d0a9.0850c","name":"Broker (topic: SENSOR/3)","topic":"F0B5D1A48F4E0000/SENSOR/3","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":550,"y":1380,"wires":[["2b56df6e.b760c"]]},{"id":"84badfb6.a1554","type":"mqtt in","z":"d133d0a9.0850c","name":"Broker (topic: SENSOR/4)","topic":"F0B5D1A48F4E0000/SENSOR/4","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":570,"y":1700,"wires":[["ae365240.fab0b"]]},{"id":"8da50aca.e3b308","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":7,"width":8,"height":1,"name":"Y Average value","label":"Average value :","format":"{{msg.payload.avgValue}}","layout":"row-center","x":1140,"y":1020,"wires":[]},{"id":"5b52a0a5.3f904","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":8,"width":4,"height":1,"name":"y start time","label":"Start time:","format":"{{msg.payload.startTime}}","layout":"row-center","x":1130,"y":1140,"wires":[]},{"id":"996e489f.99a4e8","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":1,"width":4,"height":1,"name":"Y Maximum Measurment","label":"Maximum Measurment:","format":"{{msg.payload.maxValue}}","layout":"row-center","x":1170,"y":940,"wires":[]},{"id":"c898f815.804928","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":9,"width":4,"height":1,"name":"y end time","label":"End time:","format":"{{msg.payload.endTime}}","layout":"row-center","x":1130,"y":1180,"wires":[]},{"id":"d61e6f0f.fbd02","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":2,"width":4,"height":1,"name":"y max event time","label":"Event time:","format":"{{msg.payload.maxEventTime}}","layout":"row-center","x":1150,"y":1060,"wires":[]},{"id":"7f19c8c3.bf8788","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":4,"width":4,"height":1,"name":"Y Minimum Measurmen","label":"Minimum Measurment:","format":"{{msg.payload.minValue}}","layout":"row-center","x":1170,"y":980,"wires":[]},{"id":"6698f99f.d77c98","type":"ui_text","z":"d133d0a9.0850c","group":"ef404540.ad5738","order":5,"width":4,"height":1,"name":"y min event time","label":"Event time:","format":"{{msg.payload.minEventTime}}","layout":"row-center","x":1140,"y":1100,"wires":[]},{"id":"d5a69998.79a198","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":7,"width":12,"height":1,"name":"Inc_X Average value","label":"Average value :","format":"{{msg.payload.avgValue}}","layout":"row-center","x":1160,"y":1340,"wires":[]},{"id":"35f1af0e.693b9","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":8,"width":6,"height":1,"name":"Inc_X start time","label":"Start time:","format":"{{msg.payload.startTime}}","layout":"row-center","x":1140,"y":1460,"wires":[]},{"id":"7615ed2d.0f4144","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":1,"width":6,"height":1,"name":"Inc_X Maximum Measurment","label":"Maximum Measurment:","format":"{{msg.payload.maxValue}}","layout":"row-center","x":1180,"y":1260,"wires":[]},{"id":"3c2f1100.5ab75","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":9,"width":6,"height":1,"name":"Inc_X end time","label":"End time:","format":"{{msg.payload.endTime}}","layout":"row-center","x":1140,"y":1500,"wires":[]},{"id":"5ca2122d.d4f3bc","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":2,"width":6,"height":1,"name":"Inc_X max event time","label":"Event time:","format":"{{msg.payload.maxEventTime}}","layout":"row-center","x":1160,"y":1380,"wires":[]},{"id":"8fbd69de.d0f948","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":4,"width":6,"height":1,"name":"Inc_X Minimum Measurmen","label":"Minimum Measurment:","format":"{{msg.payload.minValue}}","layout":"row-center","x":1180,"y":1300,"wires":[]},{"id":"5f11b918.be44c8","type":"ui_text","z":"d133d0a9.0850c","group":"65741de5.2a6734","order":5,"width":6,"height":1,"name":"Inc_X min event time","label":"Event time:","format":"{{msg.payload.minEventTime}}","layout":"row-center","x":1160,"y":1420,"wires":[]},{"id":"f3481e47.d6056","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":7,"width":12,"height":1,"name":"Inc_Y Average value","label":"Average value :","format":"{{msg.payload.avgValue}}","layout":"row-center","x":1160,"y":1660,"wires":[]},{"id":"d38e2cff.dc2d3","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":8,"width":6,"height":1,"name":"Inc_Y start time","label":"Start time:","format":"{{msg.payload.startTime}}","layout":"row-center","x":1140,"y":1780,"wires":[]},{"id":"acfead9a.5c83e","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":1,"width":6,"height":1,"name":"Inc_Y Maximum Measurment","label":"Maximum Measurment:","format":"{{msg.payload.maxValue}}","layout":"row-center","x":1180,"y":1580,"wires":[]},{"id":"abf92208.db6ef","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":9,"width":6,"height":1,"name":"Inc_Y end time","label":"End time:","format":"{{msg.payload.endTime}}","layout":"row-center","x":1140,"y":1820,"wires":[]},{"id":"ede293d5.dc5d4","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":2,"width":6,"height":1,"name":"Inc_Y max event time","label":"Event time:","format":"{{msg.payload.maxEventTime}}","layout":"row-center","x":1160,"y":1700,"wires":[]},{"id":"82bb5189.becb7","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":4,"width":6,"height":1,"name":"Inc_Y Minimum Measurmen","label":"Minimum Measurment:","format":"{{msg.payload.minValue}}","layout":"row-center","x":1180,"y":1620,"wires":[]},{"id":"c232775b.14d298","type":"ui_text","z":"d133d0a9.0850c","group":"20f4c874.ca2f18","order":5,"width":6,"height":1,"name":"Inc_Y min event time","label":"Event time:","format":"{{msg.payload.minEventTime}}","layout":"row-center","x":1160,"y":1740,"wires":[]},{"id":"42471724.8da368","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":9,"width":4,"height":1,"name":"x end time","label":"End time:","format":"{{msg.payload.endTime}}","layout":"row-center","x":1130,"y":860,"wires":[]},{"id":"6a59672a.f47448","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":8,"width":4,"height":1,"name":"X start time","label":"Start time:","format":"{{msg.payload.startTime}}","layout":"row-center","x":1130,"y":820,"wires":[]},{"id":"1fd59c70.781b44","type":"ui_text","z":"d133d0a9.0850c","group":"fe2e106f.0b6b1","order":7,"width":8,"height":1,"name":"X Average value","label":"Average value :","format":"{{msg.payload.avgValue}}","layout":"row-center","x":1140,"y":700,"wires":[]},{"id":"218ef623.7d97ca","type":"function","z":"a24aab61.564278","name":"parsing","func":"// Decalre variable for each object we need from the MQTT frame\nvar deviceType = {}\nvar dacType = {}\nvar channelId = {}\nvar mathResultId = {}\nvar eventTime = {}\nvar startTime = {}\nvar endTime = {}\nvar data = {}\n\n/*******************************/\n/* Parsing the LDC Math Result frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// channel id\nchannelId.payload = msg.payload[2]\n\n// math result id (type)\nmathResultId.payload = msg.payload[3]\n\n// Event time (in Unix format) (4 bytes) \neventTime.payload = []\nfor(i=0; i<4; i++){\n    eventTime.payload[i] = msg.payload[4+i]\n}\n\n// Start time (in Unix format) (4 bytes) \nstartTime.payload = []\nfor(i=0; i<4; i++){\n    startTime.payload[i] = msg.payload[8+i]\n}\n\n// End time (in Unix format) (4 bytes) \nendTime.payload = []\nfor(i=0; i<4; i++){\n    endTime.payload[i] = msg.payload[12+i]\n}   \n\n// data in 3 bytes\ndata.payload = []\nfor(i=0; i<3; i++){\n    data.payload[i] = msg.payload[16+i]\n}\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, data , mathResultId, eventTime, startTime, endTime, channelId]","outputs":8,"noerr":0,"x":300,"y":500,"wires":[["314c97f9.63b768"],["eb12c7f7.b649b8"],["61bba345.dbfe9c"],["eea1f26f.a0865"],["5452cf1c.c5913"],["e47206d6.ebae88"],["90958f34.fc682"],["b8dda9a2.637f38"]]},{"id":"314c97f9.63b768","type":"function","z":"a24aab61.564278","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":520,"y":240,"wires":[["7bf8b67b.86c548"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"eb12c7f7.b649b8","type":"function","z":"a24aab61.564278","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"Ldc Math Result\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    case 0x07:\n        dacMode.payload = \"Dynamic math result\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":520,"y":300,"wires":[["7bf8b67b.86c548"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"5452cf1c.c5913","type":"function","z":"a24aab61.564278","name":"get-eventTimestamp","func":"var eventTimestamp = {}\neventTimestamp.topic = \"eventTimestamp\"\n\n// timestamp\neventTimestamp.payload = 0x00000000\neventTimestamp.payload |= msg.payload[0]\neventTimestamp.payload |= msg.payload[1]<<8\neventTimestamp.payload |= msg.payload[2]<<16\neventTimestamp.payload |= msg.payload[3]<<24\n\n\nreturn eventTimestamp;","outputs":1,"noerr":0,"x":540,"y":520,"wires":[["91c3f6fe.a989e8"]]},{"id":"7bf8b67b.86c548","type":"join","z":"a24aab61.564278","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":850,"y":240,"wires":[[]]},{"id":"b8dda9a2.637f38","type":"function","z":"a24aab61.564278","name":"get_channelName","func":"var channelName = {}\nchannelName.topic = \"channelName\"\n\nswitch(msg.payload){\n    case 0x00:\n        channelName.payload = \"Ch_Z\"\n        break;\n    case 0x01:\n        channelName.payload = \"Ch_X\"\n        break;\n    case 0x02:\n        channelName.payload = \"Ch_Y\"\n        break;\n    case 0x03:\n        channelName.payload = \"Inc_X\"\n        break;\n    case 0x04:\n        channelName.payload = \"Inc_Y\"\n        break\n    default:\n        channelName.payload = \"Unknow\"\n        break;\n}\n\nreturn channelName;","outputs":1,"noerr":0,"x":530,"y":720,"wires":[[]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"61bba345.dbfe9c","type":"function","z":"a24aab61.564278","name":"get_data","func":"// input\nvar dataHex = msg.payload\n// output\nvar data = {}\ndata.topic = \"data\"\n\n// measurement in 3 bytes , LSB first and last bit is a sign bit\n// convert hex to decimal\ndata.payload = 0x000000\ndata.payload |= dataHex[0]\ndata.payload |= (dataHex[1]<<8) \ndata.payload |= (dataHex[2]&0x7f<<16)\n\n//if sign bit equal 1 the measurement is negative\nif((dataHex[2]&0x80)==0x80){\n    data.payload *= -1\n}\n\n// divide data by 1000 to get the real measurement\ndata.payload = data.payload/1000\n\nreturn data;","outputs":1,"noerr":0,"x":520,"y":380,"wires":[["6ead3c1f.5537d4"]]},{"id":"eea1f26f.a0865","type":"function","z":"a24aab61.564278","name":"get_mathResultType","func":"var mathResultType = {}\nmathResultType.topic = \"mathResultType\"\n\nswitch(msg.payload){\n    case 0x01:\n        mathResultType.payload = \"Maximum\"\n        break;\n    case 0x02:\n        mathResultType.payload = \"Minimum\"\n        break;\n    case 0x03:\n        mathResultType.payload = \"Average\"\n        break;\n    default:\n        mathResultType.payload = \"Unknow\"\n        break;\n}\n\nreturn mathResultType;","outputs":1,"noerr":0,"x":540,"y":460,"wires":[["91c3f6fe.a989e8","6ead3c1f.5537d4"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"e47206d6.ebae88","type":"function","z":"a24aab61.564278","name":"get-startTimestamp","func":"var startTimestamp = {}\nstartTimestamp.topic = \"startTimestamp\"\n\n// timestamp\nstartTimestamp.payload = 0x00000000\nstartTimestamp.payload |= msg.payload[0]\nstartTimestamp.payload |= msg.payload[1]<<8\nstartTimestamp.payload |= msg.payload[2]<<16\nstartTimestamp.payload |= msg.payload[3]<<24\n\nreturn startTimestamp;","outputs":1,"noerr":0,"x":530,"y":580,"wires":[["91c3f6fe.a989e8"]]},{"id":"90958f34.fc682","type":"function","z":"a24aab61.564278","name":"get-endTimestamp","func":"var endTimestamp = {}\nendTimestamp.topic = \"endTimestamp\"\n\n// timestamp\nendTimestamp.payload = 0x00000000\nendTimestamp.payload |= msg.payload[0]\nendTimestamp.payload |= msg.payload[1]<<8\nendTimestamp.payload |= msg.payload[2]<<16\nendTimestamp.payload |= msg.payload[3]<<24\n\nreturn endTimestamp;","outputs":1,"noerr":0,"x":530,"y":620,"wires":[["91c3f6fe.a989e8"]]},{"id":"a288c1ad.3c5b7","type":"function","z":"a24aab61.564278","name":"select time converter","func":"// this function will return the timestamp depends on the math result type\n// if math result type is average then return start and end timestamps\n// if math result type is minimum or maximum then return only the event timestamp\n\n// input\nvar mathResultType = msg.payload.mathResultType\nvar eventTimestamp = msg.payload.eventTimestamp\nvar startTimestamp = msg.payload.startTimestamp\nvar endTimestamp = msg.payload.endTimestamp\n\n// output\n// time structon is [eventtimestamp for maximum value, eventtimestamp for minimum value, startTimestamp, endTimestamp]\nvar time = [null, null, null, null]\n\nif(mathResultType==\"Maximum\"){\n    time[0] = {}\n    time[0].payload = eventTimestamp.toString()\n}\nelse if(mathResultType==\"Minimum\"){\n    time[1] = {}\n    time[1].payload = eventTimestamp.toString()\n}\nelse if(mathResultType==\"Average\"){\n    time[2] = {}\n    time[2].payload = startTimestamp.toString()\n    time[3] = {}\n    time[3].payload = endTimestamp.toString()\n}\n\nreturn time;","outputs":4,"noerr":0,"x":960,"y":620,"wires":[["5ea72cda.164f94"],["f00f08b5.851338"],["8d3962e2.a0a9c"],["8ece34bb.115898"]]},{"id":"5ea72cda.164f94","type":"moment","z":"a24aab61.564278","name":"max event time","topic":"maxEventTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1200,"y":520,"wires":[["a40df951.e6c6c8"]]},{"id":"8d3962e2.a0a9c","type":"moment","z":"a24aab61.564278","name":"start time","topic":"startTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1180,"y":600,"wires":[["534d52c5.78165c"]]},{"id":"8ece34bb.115898","type":"moment","z":"a24aab61.564278","name":"end time","topic":"endTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1180,"y":640,"wires":[["534d52c5.78165c"]]},{"id":"91c3f6fe.a989e8","type":"join","z":"a24aab61.564278","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"4","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":770,"y":620,"wires":[["a288c1ad.3c5b7"]]},{"id":"f00f08b5.851338","type":"moment","z":"a24aab61.564278","name":"min event time","topic":"minEventTime","input":"","inputType":"msg","inTz":"ETC/GMT","adjAmount":0,"adjType":"days","adjDir":"add","format":"DD/MM/YYYY HH:mm:ss","locale":"fr_FR","output":"","outputType":"msg","outTz":"ETC/GMT","x":1200,"y":560,"wires":[["37347381.b212bc"]]},{"id":"6ead3c1f.5537d4","type":"join","z":"a24aab61.564278","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":770,"y":380,"wires":[["5f85c782.eff2f8"]]},{"id":"5f85c782.eff2f8","type":"function","z":"a24aab61.564278","name":"data separator","func":"\n// input\nvar mathResultType = msg.payload.mathResultType\nvar data = msg.payload.data\n\n// output\nvar output = [null, null, null]\n\nif(mathResultType==\"Maximum\"){\n    output[0] = {}\n    output[0].topic = \"maxValue\"\n    output[0].payload = data\n}\nelse if(mathResultType==\"Minimum\"){\n    output[1] = {}\n    output[1].topic = \"minValue\"\n    output[1].payload = data\n}\nelse if(mathResultType==\"Average\"){\n    output[2] = {}\n    output[2].topic = \"avgValue\"\n    output[2].payload = data\n}\n\nreturn output;","outputs":3,"noerr":0,"x":1180,"y":380,"wires":[["a40df951.e6c6c8"],["37347381.b212bc"],["534d52c5.78165c"]]},{"id":"534d52c5.78165c","type":"join","z":"a24aab61.564278","name":"Avg join","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1400,"y":640,"wires":[["b1afe423.6a3fb8"]]},{"id":"a40df951.e6c6c8","type":"join","z":"a24aab61.564278","name":"Max join","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":1400,"y":360,"wires":[["7ca1796a.1ad2f8"]]},{"id":"37347381.b212bc","type":"join","z":"a24aab61.564278","name":"Min join","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1400,"y":500,"wires":[["dc833abf.1d2a98"]]},{"id":"7ca1796a.1ad2f8","type":"change","z":"a24aab61.564278","name":"Max","rules":[{"t":"set","p":"topic","pt":"msg","to":"max","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1530,"y":360,"wires":[[]]},{"id":"dc833abf.1d2a98","type":"change","z":"a24aab61.564278","name":"Min","rules":[{"t":"set","p":"topic","pt":"msg","to":"min","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1530,"y":500,"wires":[[]]},{"id":"b1afe423.6a3fb8","type":"change","z":"a24aab61.564278","name":"Avg","rules":[{"t":"set","p":"topic","pt":"msg","to":"avg","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1530,"y":640,"wires":[[]]},{"id":"dd3e7473.3ceef8","type":"function","z":"a24aab61.564278","name":"MQTT frame verification","func":"/*\nBecause the Static topic is not reserved only for Alarm mode data\n(shared with LDC mode and ldc math result),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x02 \nwhich is the code for the Alarm mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's from Alarm mode\nif(msg.payload[1]!=0x05){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":900,"wires":[["218ef623.7d97ca"]]},{"id":"68db4e4b.95b99","type":"subflow:a24aab61.564278","z":"d133d0a9.0850c","name":"","env":[],"x":860,"y":420,"wires":[["1810eb44.b37f55"],["abea9a78.b75f78","6c91c963.271888"],["cb5705a4.1cfb88","59e307fc.f14ec8"],["a79a1021.58a7c","bf6e06ca.440fc8","7632e8c5.f6c948"],[]]},{"id":"1810eb44.b37f55","type":"ui_text","z":"d133d0a9.0850c","group":"158893dd.30fb5c","order":1,"width":0,"height":0,"name":"device type and dac mode","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\" ","layout":"row-center","x":1170,"y":200,"wires":[]},{"id":"389373d2.b42c9c","type":"subflow:a24aab61.564278","z":"d133d0a9.0850c","name":"","env":[],"x":860,"y":740,"wires":[[],["12c8c135.e9da5f","7b0634a9.26d59c"],["7c451476.3dd39c","5973f8bd.0843b8"],["1fd59c70.781b44","6a59672a.f47448","42471724.8da368"],[]]},{"id":"a534b993.0ad078","type":"subflow:a24aab61.564278","z":"d133d0a9.0850c","name":"","env":[],"x":860,"y":1060,"wires":[[],["996e489f.99a4e8","d61e6f0f.fbd02"],["7f19c8c3.bf8788","6698f99f.d77c98"],["8da50aca.e3b308","5b52a0a5.3f904","c898f815.804928"],[]]},{"id":"2b56df6e.b760c","type":"subflow:a24aab61.564278","z":"d133d0a9.0850c","name":"","env":[],"x":860,"y":1380,"wires":[[],["5ca2122d.d4f3bc","7615ed2d.0f4144"],["5f11b918.be44c8","8fbd69de.d0f948"],["3c2f1100.5ab75","35f1af0e.693b9","d5a69998.79a198"],[]]},{"id":"ae365240.fab0b","type":"subflow:a24aab61.564278","z":"d133d0a9.0850c","name":"","env":[],"x":880,"y":1700,"wires":[[],["acfead9a.5c83e","ede293d5.dc5d4"],["82bb5189.becb7","c232775b.14d298"],["f3481e47.d6056","d38e2cff.dc2d3","abf92208.db6ef"],[]]}]
[{"id":"53382208.28f12c","type":"tab","label":"MQTT Client for Alarm 1_4_2020","disabled":false,"info":""},{"id":"5ae65c2d.8b7854","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/0)","topic":"F0B5D1A48F4E0000/SENSOR/0","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":380,"wires":[["3d3983b1.4304fc"]]},{"id":"9d1c7e48.9ffd1","type":"function","z":"53382208.28f12c","name":"parsing","func":"// Decalre variable for each object we need from the MQTT frame\nvar deviceType = {}\nvar dacType = {}\nvar channelId = {}\nvar time = {}\nvar alarmStatus = {}\nvar data = {}\n\n/*******************************/\n/* Parsing the Alarm frame */\n/*******************************/\n// device type in 1 byte\ndeviceType.payload = msg.payload[0]\n\n// acquasition mode in 1 byte\ndacType.payload = msg.payload[1]\n\n// channel id\nchannelId.payload = msg.payload[2]\n\n// Reference time (in Unix format) (4 bytes) \ntime.payload = []\nfor(i=0; i<4; i++){\n    time.payload[i] = msg.payload[3+i]\n}\n\n// alarm status in 1 byte\nalarmStatus.payload = msg.payload[7]\n\n// data in 3 bytes\ndata.payload = []\nfor(i=0; i<3; i++){\n    data.payload[i] = msg.payload[8+i]\n}\n\n\n/***********************************/\n/* return all field in array object*/\n/***********************************/\nreturn [deviceType, dacType, alarmStatus, channelId, time, data]","outputs":6,"noerr":0,"x":640,"y":500,"wires":[["e221024b.d466e"],["a1b345bd.7a58e8"],["d689222b.93145"],["b2ca9722.713f18"],["1bc90eb1.9b0831"],["3ae27d2e.5898a2"]]},{"id":"e221024b.d466e","type":"function","z":"53382208.28f12c","name":"get_deviceType","func":"var deviceType = {}\ndeviceType.topic = \"deviceType\"\nswitch(msg.payload){\n    case 0x01:\n        deviceType.payload = \"AX 3D\"\n        break;\n    case 0x02:\n        deviceType.payload = \"HI- INC MONO\"\n        break;\n    case 0x03:\n        deviceType.payload = \"HI- INC BI\"\n        break;\n    case 0x04:\n        deviceType.payload = \"X- INC MONO\"\n        break\n    case 0x05:\n        deviceType.payload = \"X- INC BI\"\n        break;\n    case 0x06:\n        deviceType.payload = \"AX 3DS\"\n        break;\n    default:\n        deviceType.payload = \"Unknow\"\n        break;\n        \n}\nreturn deviceType;","outputs":1,"noerr":0,"x":880,"y":340,"wires":[["16cc8e6f.aced42"]],"info":"This function get as input the device type code which is a hex value to decode it and return the device type in a readable format."},{"id":"a1b345bd.7a58e8","type":"function","z":"53382208.28f12c","name":"get_dacMode","func":"var dacMode = {}\ndacMode.topic = \"dacMode\"\nswitch(msg.payload){\n    case 0x01:\n        dacMode.payload = \"LowDutyCycle\"\n        break;\n    case 0x02:\n        dacMode.payload = \"Alarm\"\n        break;\n    case 0x03:\n        dacMode.payload = \"Streaming\"\n        break;\n    case 0x04:\n        dacMode.payload = \"Shock Detection\"\n        break\n    case 0x05:\n        dacMode.payload = \"later\"\n        break;\n    case 0x06:\n        dacMode.payload = \"S.E.T\"\n        break;\n    default:\n        dacMode.payload = \"Unknow\"\n        break;\n        \n}\nreturn dacMode;","outputs":1,"noerr":0,"x":880,"y":400,"wires":[["16cc8e6f.aced42"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"1bc90eb1.9b0831","type":"function","z":"53382208.28f12c","name":"get-timestamp","func":"var time_timeStamp = {}\ntime_timeStamp.topic = \"time_timestamp\"\n\n// timestamp\ntime_timeStamp.payload = 0x00000000\ntime_timeStamp.payload |= msg.payload[0]\ntime_timeStamp.payload |= msg.payload[1]<<8\ntime_timeStamp.payload |= msg.payload[2]<<16\ntime_timeStamp.payload |= msg.payload[3]<<24\n\n\nreturn time_timeStamp;","outputs":1,"noerr":0,"x":880,"y":580,"wires":[["dfd6d4cb.79af18"]]},{"id":"dfd6d4cb.79af18","type":"join","z":"53382208.28f12c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1110,"y":640,"wires":[["fcb59871.578ac8","c8d7b689.7abde8"]]},{"id":"fcb59871.578ac8","type":"function","z":"53382208.28f12c","name":"to accelerometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"ch\" because accelerometer sensors's name start with ch\nfilter = \"ch\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedAccelerometerMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    \n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1600,"y":600,"wires":[["c83a41d6.e9ff8"]]},{"id":"c83a41d6.e9ff8","type":"ui_chart","z":"53382208.28f12c","name":"Accelerometer","group":"af71a73e.e1d838","order":2,"width":12,"height":6,"label":"Accelerometer (g)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1840,"y":600,"wires":[[]]},{"id":"e99703ba.47e9d","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":1,"width":25,"height":1,"name":"","label":"","format":"{{msg.payload.deviceType}} \"{{msg.payload.dacMode}}\" ","layout":"col-center","x":1810,"y":340,"wires":[]},{"id":"16cc8e6f.aced42","type":"join","z":"53382208.28f12c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":340,"wires":[["e99703ba.47e9d"]]},{"id":"f3b56019.e96f6","type":"ui_chart","z":"53382208.28f12c","name":"Inclinometer ","group":"af71a73e.e1d838","order":4,"width":12,"height":6,"label":"Inclinometer (deg)","chartType":"line","legend":"true","xformat":"HH:mm:ss DD/MM/YYYY","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":"20","removeOlderPoints":"5000","removeOlderUnit":"1","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":1830,"y":640,"wires":[[]]},{"id":"3d3983b1.4304fc","type":"function","z":"53382208.28f12c","name":"MQTT frame verification","func":"/*\nBecause the Static topic is not reserved only for Alarm mode data\n(shared with LDC mode and ldc math result),\nwe need to filter the message payload come from the BeanDevice \nand select only the frame with acquasition mode equal to 0x02 \nwhich is the code for the Alarm mode.\n(Note: all frames comes from any acquisition mode start with:\n    device type (first byte),\n    acquasition mode (second byte),\n    the rest of the frame it depends on the dac mode)\n*/\n\n// verify if it's from Alarm mode\nif(msg.payload[1]!=0x02){\n    // by returning nothing, the next node will receive nothing which mean it will not start\n    return;\n}\nreturn msg;","outputs":1,"noerr":0,"x":430,"y":500,"wires":[["9d1c7e48.9ffd1"]]},{"id":"1ee101a1.bc297e","type":"comment","z":"53382208.28f12c","name":"Read me","info":"Company: BeanAir\nDate:   01/04/2020\nAuthor: Habib jomaa\nDescription:\nThis Example uses MQTT protocol to collect data measurments from a BeanDevice in Alarm mode and display it in graph along\nwith the alarm status for each channel.\nThe beandevice used is \"X-Inc\" with 5 channels active and the broker is \"broker.hivemq.com\", so make sure to:\n    + set your machine's timezone to UTC to get the correct time sent from BeanDevice (because the Dashboard package automaticly convert time to the time zone in host machine)\n    + set your configuration right before running the example.\n    + connect this flow and the BeanDevice to the same broker.\n    (you can change the the accelerometer and inclinometer chart nodes and dashboard in the way you like, and to set the maxsize of the stored data you need to change the varaible \"graphMaxSize\" in node \"to accelerometer dashboard\" and \"to inclinometer dashboard\")\n\nInformations we need:\n    Alarm frame content:\n+(0)---------+(1)------+(2)--------+(3)------------+(7)----------+(8)---------+(11)\n|Device type |DAC type |Channel id |Reference time |Alarm status |Data sample |\n|(1 byte)    |(1 byte) |(1byte)    |(4 bytes)      |(1 byte)     |(3 bytes)   |\n+------------+---------+-----------+---------------+-------------+------------+\n\n(Note: \n    + Date time is in Unix format (LSB first)\n    + Alarm status are 4:\n        * 0x00 No Alarm\n        * 0x01 Alarm start\n        * 0x02 Alarm in progress\n        * 0x03 Alarm end\n    + Data sample (LSB first), the last bit is a sign bit and the rest is the absolute value multiplied by 1000 (to avoid using float number)\n      so don't forget the divide it by 1000 to get the correct measurment\n\nRelated document:\n    + TN-RF-19-BeanDevice-Wilow-IoT-starter-Guidelines-using-MQTT-protocol-with-NodeRed.pdf (see www.wireless-iot.beanair.com support section)\n    \nReference\ndocuement http://www.wireless-iot.beanair.com/files/TN-RF-004-MQTT-Comnmunication-Protocol.pdf\n\nPreparation:\n1- Configure the beandevice to use the MQTT mode\n2- Make sure to enable the topic for static measurement of each channel\n3- Don't forget to set the threshold of each channel\n4- Start running the beandevice in Alarm mode\n\nSteps:\n1- connect to the broker\n2- subscribe to each sensor's topic (static measurment topics)\n3- wait for payloads\n4- check DAC type if it's Alarm\n5- parse the coming payload\n6- display data in graph\n7- display the Alarm status for each channel\n'''","x":80,"y":280,"wires":[]},{"id":"b2ca9722.713f18","type":"function","z":"53382208.28f12c","name":"get_channelName","func":"var channelName = {}\nchannelName.topic = \"channelName\"\n\nswitch(msg.payload){\n    case 0x00:\n        channelName.payload = \"Ch_Z\"\n        break;\n    case 0x01:\n        channelName.payload = \"Ch_X\"\n        break;\n    case 0x02:\n        channelName.payload = \"Ch_Y\"\n        break;\n    case 0x03:\n        channelName.payload = \"Inc_X\"\n        break;\n    case 0x04:\n        channelName.payload = \"Inc_Y\"\n        break\n    default:\n        channelName.payload = \"Unknow\"\n        break;\n}\n\nreturn channelName;","outputs":1,"noerr":0,"x":890,"y":520,"wires":[["dfd6d4cb.79af18","bc21e6c0.2640c8"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"3ae27d2e.5898a2","type":"function","z":"53382208.28f12c","name":"get_data","func":"// input\nvar dataHex = msg.payload\n// output\nvar data = {}\ndata.topic = \"data\"\n\n// measurement in 3 bytes , LSB first and last bit is a sign bit\n// convert hex to decimal\ndata.payload = 0x000000\ndata.payload |= dataHex[0]\ndata.payload |= (dataHex[1]<<8) \ndata.payload |= (dataHex[2]&0x7f<<16)\n\n//if sign bit equal 1 the measurement is negative\nif((dataHex[2]&0x80)==0x80){\n    data.payload *= -1\n}\n\n// divide data by 1000 to get the real measurement\ndata.payload = data.payload/1000\n\nreturn data;","outputs":1,"noerr":0,"x":860,"y":640,"wires":[["dfd6d4cb.79af18"]]},{"id":"5c991daa.06ce54","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/1)","topic":"F0B5D1A48F4E0000/SENSOR/1","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":440,"wires":[["3d3983b1.4304fc"]]},{"id":"b12195af.046a68","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/2)","topic":"F0B5D1A48F4E0000/SENSOR/2","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":500,"wires":[["3d3983b1.4304fc"]]},{"id":"eee50406.cd10d8","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/3)","topic":"F0B5D1A48F4E0000/SENSOR/3","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":560,"wires":[["3d3983b1.4304fc"]]},{"id":"62933e7b.4c6cd","type":"mqtt in","z":"53382208.28f12c","name":"Broker (topic: SENSOR/4)","topic":"F0B5D1A48F4E0000/SENSOR/4","qos":"0","datatype":"auto","broker":"5ab5d8b8.d82498","x":130,"y":620,"wires":[["3d3983b1.4304fc"]]},{"id":"c8d7b689.7abde8","type":"function","z":"53382208.28f12c","name":"to inclinometer dashboard","func":"/* input */\nvar channelName = msg.payload.channelName\nvar data = msg.payload.data\nvar timestamp = msg.payload.time_timestamp\n/* configuration */\n// use a commun sub_word of the channel name as filter\n// \"inc\" because inclinometer sensors's name start with inc\nfilter = \"inc\"\n// the variable label of the old measurement in the context\nstoredMeasurementBuffer_variableName = \"storedInclMeasurements\"\n// maximum number to get from the old measurement\ngraphMaxSize = 30\n/* saved data */\nvar storedMeasurements = flow.get(storedMeasurementBuffer_variableName)\n/* output */\nvar dashboardData = {}\ndashboardData.payload = []\n\n// filter\nif(channelName.toLowerCase().includes(filter)){\n    //   check if there old data stored before\n    if (typeof storedMeasurements != \"object\"){\n        // if no measurement was stored before, init storedMeasurements variable\n        storedMeasurements={}\n        // graph labels. (no need to use any label)\n        storedMeasurements.labels=[]\n        // graph series (fill it later)\n        storedMeasurements.series=[]\n        // graph data (measurement)\n        storedMeasurements.data=[]\n    }\n    \n    // add channel name to list of series if not exist\n    var channelPosInSeries = 0\n    if((channelPosInSeries=storedMeasurements.series.indexOf(channelName))==-1){\n        storedMeasurements.series.push(channelName)\n        channelPosInSeries = storedMeasurements.series.length - 1\n        storedMeasurements.data[channelPosInSeries] = []\n    }\n    \n    // add new measurements with the corresponding time to the data list\n    var element = {}\n    element.y = data\n    element.x = timestamp * 1000 // multiply by 1000 because dashboard accept timestamp in milliseconds\n    storedMeasurements.data[channelPosInSeries].push(element)\n    \n    // resize stored data to not pass the max size\n    if(storedMeasurements.data[channelPosInSeries].length>graphMaxSize){\n        var stop=storedMeasurements.data[channelPosInSeries].length\n        var start=stop-graphMaxSize\n        tempBuffer = []\n        for(; start<stop; start++){\n            tempBuffer.push(storedMeasurements.data[channelPosInSeries][start])\n        }\n        storedMeasurements.data[channelPosInSeries] = tempBuffer\n    }\n\n//save measurements\nflow.set(storedMeasurementBuffer_variableName, storedMeasurements)\n\ndashboardData.payload.push(storedMeasurements)\nreturn dashboardData\n}\nreturn","outputs":1,"noerr":0,"x":1590,"y":640,"wires":[["f3b56019.e96f6"]]},{"id":"d689222b.93145","type":"function","z":"53382208.28f12c","name":"get_AlarmStatus","func":"var alarmStatus = {}\nalarmStatus.topic = \"alarmStatus\"\nswitch(msg.payload){\n    case 0x00:\n        alarmStatus.payload = \"No Alarm\"\n        break\n    case 0x01:\n        alarmStatus.payload = \"Alarm start\"\n        break;\n    case 0x02:\n        alarmStatus.payload = \"Alarm in progress\"\n        break;\n    case 0x03:\n        alarmStatus.payload = \"Alarm end\"\n        break;\n    default:\n        alarmStatus.payload = \"Unknow\"\n        break;\n}\nreturn alarmStatus;","outputs":1,"noerr":0,"x":890,"y":460,"wires":[["bc21e6c0.2640c8"]],"info":"This function get as input the dac mode code which is a hex value to decode it and return the dac mode in a readable format."},{"id":"bc21e6c0.2640c8","type":"join","z":"53382208.28f12c","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":460,"wires":[["16b3fdce.9a6812"]]},{"id":"90274bce.4f78d8","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":10,"width":4,"height":1,"name":"ch_z alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"col-center","x":1830,"y":380,"wires":[]},{"id":"16b3fdce.9a6812","type":"function","z":"53382208.28f12c","name":"update alarm status","func":"var storedChannelsAlarmStatus = flow.get(\"storedChannelsAlarmStatus\")\n\n// get list of channels from flow context variable of each sensor type\nvar channelName = msg.payload.channelName\nvar alarmStatus = msg.payload.alarmStatus\n\nvar channelExist = false\n\nif (typeof storedChannelsAlarmStatus == \"object\"){\n    for(var i=0; i<storedChannelsAlarmStatus.length; i++){\n        if(channelName==storedChannelsAlarmStatus[i].channelName){\n            channelExist = true\n            storedChannelsAlarmStatus[i].alarmStatus = alarmStatus\n        }\n    }\n}\nelse{\n    // if we didn't store measurement before, we need to decalare the global variable as an array\n    storedChannelsAlarmStatus = []\n}\nif(channelExist==false){\n    storedChannelsAlarmStatus.push({\"channelName\":channelName,\"alarmStatus\":alarmStatus})\n}\n\n\n//save measurements\nflow.set(\"storedChannelsAlarmStatus\", storedChannelsAlarmStatus)\nmsg.topic = \"listChannelAlarmStatus\"\nmsg.payload = storedChannelsAlarmStatus\nreturn msg;","outputs":1,"noerr":0,"x":1310,"y":460,"wires":[["71e374b9.68551c"]]},{"id":"46d49e64.8d1d2","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":11,"width":4,"height":1,"name":"ch_x alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"col-center","x":1830,"y":420,"wires":[]},{"id":"1c03383d.b6e8f8","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":12,"width":4,"height":1,"name":"ch_y alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"col-center","x":1830,"y":460,"wires":[]},{"id":"fe45b94f.1541b8","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":14,"width":4,"height":1,"name":"inc_x alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"row-spread","x":1830,"y":500,"wires":[]},{"id":"4fe9b9e9.767d08","type":"ui_text","z":"53382208.28f12c","group":"af71a73e.e1d838","order":16,"width":4,"height":1,"name":"inc_y alarm","label":"","format":"{{msg.payload.channelName}} => {{msg.payload.alarmStatus}}","layout":"row-spread","x":1830,"y":540,"wires":[]},{"id":"71e374b9.68551c","type":"function","z":"53382208.28f12c","name":"Array to text","func":"// BeanDevice has 5 sensors at most\n// for each one return the alarm status\n// if one of them missing the alarm status, return null\n// the out put order will be: ch_z, ch_x, ch_y, inc_x, inc_y\n// format of each element: {\"channelName\":channelName,\"alarmStatus\":alarmStatus} (the same as the input)\ninputArray = msg.payload\n\nlistChannels = [\"ch_z\", \"ch_x\", \"ch_y\", \"inc_x\", \"inc_y\"]\noutputArray = [{\"payload\":\"\"}, {\"payload\":\"\"}, {\"payload\":\"\"}, {\"payload\":\"\"}, {\"payload\":\"\"}]\n\nfor(var i=0; i<listChannels.length; i++){\n    for(var j=0; j<inputArray.length; j++){\n        if(inputArray[j].channelName.toLowerCase().includes(listChannels[i])){\n            outputArray[i].payload ={\"channelName\":inputArray[j].channelName,\"alarmStatus\":inputArray[j].alarmStatus}\n        }\n    }\n}\n\nreturn outputArray;","outputs":5,"noerr":0,"x":1550,"y":460,"wires":[["90274bce.4f78d8"],["46d49e64.8d1d2"],["1c03383d.b6e8f8"],["fe45b94f.1541b8"],["4fe9b9e9.767d08"]]},{"id":"5ab5d8b8.d82498","type":"mqtt-broker","z":"","name":"hivemq broker","broker":"broker.hivemq.com","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"af71a73e.e1d838","type":"ui_group","z":"53382208.28f12c","name":"MQTT Alarm","tab":"e3e4f23f.762d2","order":1,"disp":true,"width":"25","collapse":false},{"id":"e3e4f23f.762d2","type":"ui_tab","z":"53382208.28f12c","name":"BeanAir: Alarm","icon":"dashboard","order":3,"disabled":false,"hidden":false}]